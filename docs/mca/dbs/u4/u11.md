# Object-Oriented Databases (OODBs)

Object-oriented databases (OODBs) are database systems designed to store, manage, and manipulate data in the form of objects, as defined in object-oriented programming (OOP). These databases extend the capabilities of traditional database systems by integrating object-oriented features such as encapsulation, inheritance, polymorphism, and support for complex data structures.

They are especially well-suited for applications involving highly interrelated and complex data, such as:

- Computer-Aided Design and Manufacturing (CAD/CAM)
    
- Computer-Integrated Manufacturing (CIM)
    
- Geographic Information Systems (GIS)
    
- Telecommunications
    
- Biological Sciences
    
- Multimedia Systems
    

Many object data model features have also influenced modern NoSQL systems.

## Object-Oriented Concepts

In object-oriented systems, an **object** is an entity that encapsulates both **state** (data) and **behavior** (methods).

An object consists of:

- **State**: Represented by its attributes (values).
    
- **Behavior**: Represented by the operations (methods) defined for the object.
    
Objects may have complex internal structures and custom operations defined by the programmer.

### Transient vs. Persistent Objects

Objects are transient and exist only during the execution of a program. Object-oriented database systems extend this notion by allowing objects to persist beyond program termination.

- **Transient Objects**: Exist only during program execution; typical in traditional OOPLs.
    
- **Persistent Objects**: Stored in the database and remain accessible beyond program termination.
    
Persistent objects require integration with standard database features, including:

- **Secondary storage**
    
- **Indexing mechanisms**
    
- **Concurrency control**
    
- **Recovery and fault tolerance**
    
## Essential Features of Object-Oriented Databases

### 1. Object Identity (OID)

Each object in an OODB is assigned a unique and immutable **Object Identifier (OID)**. 

This identifier:
- Is **system-generated**
    
- Is **independent** of the object’s attribute values
    
- Is **not visible** to end users
    
OIDs are typically implemented as long integers and mapped to physical storage using hash tables or similar structures for efficient retrieval.

### 2. Encapsulation

Encapsulation is the bundling of data with the operations that manipulate that data, ensuring internal object structure is hidden.

- Internal attributes and implementation details are hidden from external access.
    
- Operations are defined through:
    
    - **Interface (signature)**: Declares operation names and parameters.
        
    - **Method (body)**: Contains the actual implementation.
        
- Operations are invoked by sending messages to objects.
    
- Encourages independence between data representation and usage.
    
## Inheritance and Type Hierarchies

Inheritance allows the definition of new classes or types that derive their structure and behavior from existing classes. 

This supports:
- **Code and model reusability**
    
- **Incremental development of schemas**
    
- **Organization into type hierarchies**
    
Some models support **multiple inheritance**, allowing a class to inherit from multiple parent classes.

## Polymorphism and Operator Overloading

**Polymorphism** or operator overloading allows the same operation name to have different implementations depending on the object's class.

- Operation name is **overloaded** with different implementations.
  
- The method to be executed is determined at **runtime** (late binding).
    
- Facilitates general and reusable interfaces.
    
**Example**:  A method `area()` may be implemented differently for `Circle`, `Rectangle`, and `Triangle`.

## Complex Type Structures

Object-oriented databases support arbitrarily complex and nested type structures through **type constructors**. The fundamental type constructors are atom, struct (or tuple), and collection.

### 1. Atom Constructor

The atom constructor corresponds to basic data types such as integers, floating-point numbers, strings, Booleans, and enumerated types. These are considered atomic because their values are indivisible and represent single data items.

Represents **atomic (single-valued) types**, such as: `int`, `float`, `string`, `bool`, `enum`
    
### 2. Struct (Tuple) Constructor

Defines composite types with named components.

The struct constructor, also known as the tuple constructor, is used to define composite types made up of multiple components. Each component has a name and an associated type.

**Example**:

```
struct Name { FirstName: string, MiddleInitial: char, LastName: string }
struct Degree { Major: string, Degree: string, Year: date }
```

### 3. Collection Constructors

Used to define multi-valued types. A collection type represents a group of elements of the same type and may be ordered or unordered. 

These are **type generators** that produce complex nested structures:

| Constructor        | Description                  |
| ------------------ | ---------------------------- |
| `set(T)`           | Unordered, unique elements   |
| `bag(T)`           | Unordered, allows duplicates |
| `list(T)`          | Ordered, variable-length     |
| `array(T)`         | Ordered, fixed-size          |
| `dictionary(K, T)` | Key-value pairs              |

**Example**:

- `set(string)`: A set of strings
    
- `set(Employee)`: A set of employee objects
    
## Encapsulation of Operations

Operations (methods) that manipulate an object’s state are defined as part of its class. 

Some operations are standard across object-oriented databases. These operations include:

|Operation Type|Description|
|---|---|
|`constructor (new)`|Creates a new object instance|
|`destructor (delete)`|Deletes an object|
|`modifier`|Updates object state|
|`accessor`|Retrieves object data|

- The **signature** of operations is visible to users.
    
- The **implementation** is typically hidden and may be defined using an external programming language enforcing encapsulation.
    
- Attributes of an object may be:
    
    - **Visible**: Accessible directly via the query language
        
    - **Hidden**: Only accessible through defined operations
        
## Persistence of Objects

Object-oriented databases support object persistence through two primary mechanisms: naming and reachability.

### 1. Naming

Named objects are given unique, persistent names that serve as entry points into the database. These names allow users and applications to retrieve specific objects directly.

- Allows retrieval by name
    
- Suitable for objects that must be accessed independently
    
### 2. Reachability

Reachability is the more commonly used method for establishing persistence.  An object is persistent if it is **reachable** from another persistent object.

- If object A references object B, and A is persistent, then B becomes persistent.
    
- This method supports **automatic persistence propagation** without requiring explicit naming for all objects.
    
## Key Concepts

Several core concepts distinguish object-oriented databases from other models:

- Each object is assigned a unique, immutable object identifier (OID) that is independent of attribute values and used internally for object management.
    
- Complex object structures are constructed using nested applications of type constructors such as tuples, sets, lists, arrays, and bags.
    
- Objects encapsulate both structure and behavior, with class definitions including both attribute declarations and operation signatures.
    
- Object-oriented databases are designed to be compatible with object-oriented programming languages, supporting both transient and persistent objects seamlessly. Persistence is achieved through reachability or naming.
    
- Inheritance allows the definition of new object types based on existing ones, supporting the reuse of structure and behavior. Multiple inheritance is supported in some models.
    
- Extents represent the set of all persistent instances of a particular class or type. They may be defined explicitly as persistent sets and are useful for organizing and querying objects of a given type.
    
- Polymorphism allows a single operation name to be used with different implementations, depending on the type of the object to which it is applied. This supports flexibility and reuse of operation names across different types.
