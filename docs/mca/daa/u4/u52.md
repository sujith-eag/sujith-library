# Hamiltonian Circuit

A **Hamiltonian circuit** is defined as a path within a graph that starts and ends at the same vertex, and passes through all other vertices in the graph exactly once. It is also described as a cycle that passes through every vertex of the graph precisely one time. 

Formally, it can be viewed as a sequence of _n_ + 1 adjacent vertices, where the initial and final vertices are identical, and all _n_ - 1 intermediate vertices are distinct.

When searching for Hamiltonian circuits in a graph, **Brute Force** and **Backtracking** are two distinct algorithmic approaches:

## Brute Force Method

The brute force method, also known as **exhaustive search**, is a straightforward approach that attempts to find a solution by **generating every possible candidate solution** and then checking each one to see if it satisfies all the problem's constraints.

- **Approach:** For a Hamiltonian circuit in a graph with _n_ vertices, a brute-force algorithm would typically involve generating all permutations of the _n_ vertices (or _n_-1 intermediate vertices if a starting point is fixed). Each generated permutation is then checked to determine if it forms a valid Hamiltonian circuit (i.e., if every successive pair of vertices in the sequence is connected by an edge, and the final vertex connects back to the starting vertex).
- **Efficiency:** This method is generally **impractical for all but very small values of _n_**. The number of permutations grows factorially (e.g., 1/2 * (n-1)! for undirected graphs, after fixing a starting vertex and another to define direction), making the exhaustive-search approach computationally infeasible as _n_ increases. Its "principal weakness is the subpar efficiency".

## Backtracking Method

Backtracking is considered a "more intelligent variation" of the brute-force approach. It systematically builds a solution **one component at a time**, and at each step, it evaluates whether the partially constructed solution has the potential to lead to a complete, valid solution.

- **Approach:**
    - The algorithm constructs the solution by making a series of choices for each component. For the Hamiltonian circuit problem, this means iteratively selecting the next vertex in the path.

	- It typically explores a **state-space tree** in a **depth-first search (DFS) fashion**. Each node in this tree represents a partially constructed path.
    
	- **Constraint Checking and Pruning:** If a partially constructed path is found to be "nonpromising" (e.g., it violates a constraint by adding a vertex already visited or leading to a dead end where no legitimate path can complete the circuit), the algorithm **terminates that path** and "backtracks" to the previous choice point to explore alternative options. This process is known as **pruning**, which significantly reduces the search space compared to brute force.
    
	- For example, when finding a Hamiltonian circuit, starting at a vertex (say, 'a'), the algorithm picks an adjacent vertex (e.g., 'b'), then from 'b' picks 'c', and so on. If it reaches a vertex (e.g., 'f') from which it cannot complete a circuit (e.g., it's a dead end), it undoes the last choice and tries another option for the previous vertex (e.g., from 'e' it backs up to 'd').

- **Efficiency:** By intelligently pruning branches that cannot lead to a solution, backtracking can **solve many large instances of NP-hard problems in an acceptable amount of time**. While still exponential in the worst case, it is generally much more efficient than pure brute force because it avoids redundant computations.

## Comparison

| Feature              | Brute Force                                                                                       | Backtracking                                                                                                                                            |
| :------------------- | :------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Core Strategy**    | **Generates and tests _all_ possible complete solutions**.                                        | **Builds solutions incrementally**, extending partial solutions and abandoning paths early if they cannot lead to a valid solution.                     |
| **"Intelligence"**   | Less intelligent; directly based on problem definition.                                           | More intelligent; a "more intelligent variation".                                                                                                       |
| **State-Space Tree** | Conceptually explores or generates the **entire state-space tree** to enumerate all candidates.   | Explicitly constructs and traverses a **state-space tree** (usually DFS-based), but **prunes non-promising branches** to avoid unnecessary computation. |
| **Efficiency**       | Highly inefficient due to factorial growth of candidates; **impractical for most problem sizes**. | More efficient than brute force due to early pruning; can solve **larger problem instances** in acceptable time, though still potentially exponential.  |
| **Constraint Check** | Checks all constraints **after** a complete candidate solution is formed.                         | Checks constraints **during** the construction of the solution; prunes if any constraint is violated.                                                   |
