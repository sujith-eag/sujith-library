## Notion of Algorithm

1.  Define an algorithm and explain its fundamental characteristics (e.g., finiteness, definiteness, input, output, effectiveness).

2.  What are the properties or characteristics of a "good" algorithm?

3.  Discuss why the study of algorithms is important in computer science.

4.  Justify the statement: "An algorithm is a notion."

5.  Provide an example of a simple real-world process that can be described as an algorithm.

6.  Differentiate between an algorithm and a program.

## Fundamentals of Algorithmic Problem Solving

1.  Outline and explain the general steps involved in the algorithm design and analysis process. You may use a flowchart to illustrate this.

2.  Describe the typical sequence of steps undertaken for algorithmic problem-solving, from understanding the problem to implementing and testing the solution.

3.  What does it mean to prove the correctness of an algorithm? Why is it important?

## Important Problem Types

1.  List and briefly explain common categories of algorithmic problems (e.g., sorting, searching, string processing, graph problems, combinatorial problems, geometric problems, numerical problems).

2.  Describe the two primary methods for representing graphs in computer memory (e.g., adjacency matrix, adjacency lists). Provide an example for each method.

3.  Explain the concepts of a graph and a weighted graph, using examples.

## Fundamentals of the Analysis of Algorithm Efficiency

### Analysis Framework

1.  Define what is meant by the time complexity and space complexity of an algorithm.

2.  Explain the concepts of worst-case, best-case, and average-case efficiency analysis for algorithms.

3.  Provide an example of an algorithm and discuss its best-case, worst-case, and average-case scenarios.

4.  Justify why worst-case analysis is often considered more important than average-case analysis in the study of algorithms.


5.  What is meant by the "input size" of an algorithm? How is it typically measured for problems like sorting, matrix multiplication, or graph traversal?

6.  Define the "running time" of an algorithm. What factors can influence it?

7.  What is the "order of growth" of an algorithm's running time? Why is it a crucial concept for comparing algorithms?

8.  What are the basic operations considered when analyzing the efficiency of an algorithm?

### Asymptotic Notations and Basic Efficiency Classes

1.  Define Big O (O), Big Omega (Ω), and Big Theta (Θ) notations. Explain the significance of each in analyzing algorithm efficiency.

2.  Provide examples for each asymptotic notation (O, Ω, Θ).

3.  Explain why asymptotic notations are necessary or beneficial in algorithm analysis.

4.  Discuss the formal definitions of O, Ω, and Θ notations.

5.  Explain the practical significance of using asymptotic notations in algorithm analysis.

6.  List and describe the basic asymptotic efficiency classes (e.g., constant, logarithmic, linear, n log n, quadratic, cubic, exponential). Provide an example algorithm for each if possible.

7.  Compare and contrast O, Ω, and Θ notations.

8.  If an algorithm has a time complexity of O(n^2), can we also say it is O(n^3)? Explain.

9.  If an algorithm has a time complexity of Θ(n), can we also say it is O(n^2)? Explain.


10.  Prove the property: If t₁(n) ∈ O(g₁(n)) and t₂(n) ∈ O(g₂(n)), then t₁(n) + t₂(n) ∈ O(max{g₁(n), g₂(n)}).

11.  For each of the following functions, indicate how its value changes if its input `n` is increased eightfold:
    a) log₂n
    b) n
    c) n²
    d) n³
    e) 2ⁿ

12.  Compare the order of growth for the following pairs of functions. State whether the first function has a smaller, larger, or the same order of growth as the second:
    a) n(n+1) and 200n⁴
    b) 2^(n-1) and 2ⁿ

13.  For the following functions, express their complexity using Big O, Big Omega, and Big Theta notation:
    a) f(n) = 10n³ + 8
    b) g(n) = 100n + 5

14.  Arrange the following functions in ascending order of their growth rates:
    (n-2)!, 5lg(n+100)¹⁰, 2²ⁿ, 0.001n⁴+3n³+1, ln²n, ³√n, 3ⁿ.

15. Using the definitions of O, Θ, and Ω, determine whether the following assertions are true or false. Justify your answers.
    a) n(n+1)/2 ∈ O(n³)
    b) n(n+1)/2 ∈ Θ(n³)
    c) n(n+1)/2 ∈ Ω(n)

16. List and explain the basic asymptotic efficiency classes (e.g., constant, logarithmic, linear, n log n, quadratic, cubic, exponential). Provide an example algorithm or function for each class and list them in ascending order of growth.

### Mathematical Analysis of Non-Recursive Algorithms

1.  Outline the general plan or steps for analyzing the time efficiency of non-recursive algorithms.
2.  Develop an algorithm for the "element uniqueness problem" (checking if all elements in a given array are distinct) and derive its time complexity.
3.  Consider the following algorithm:
    ```
    ALGORITHM Sum(n)
    // Input: A non-negative integer n
    Sum ← 0
    For i ← 1 to n do
        Sum ← Sum + i
    Return Sum
    ```
    a) What task does this algorithm perform?
    b) Identify the basic operation.
    c) Determine how many times the basic operation is executed as a function of `n`.
4.  Develop an algorithm for multiplying two `n x n` matrices and analyze its time complexity.
5.  Write a non-recursive algorithm to compute the factorial of a given non-negative integer `n` and analyze its time efficiency.
6.  Design a non-recursive algorithm to compute the sum of the squares of the first ‘n’ natural numbers (i.e., 1² + 2² + ... + n²). Analyze its time complexity.
7.  Analyze the time complexity of an algorithm that finds the maximum element in an array of `n` numbers.
8.  How do you analyze algorithms with nested loops? Provide an example.

### Mathematical Analysis of Recursive Algorithms

1.  What is a recurrence relation? How is it used to describe the efficiency of recursive algorithms?
2.  Describe the general plan or steps for analyzing the time efficiency of recursive algorithms.
3.  Explain the recursive algorithm for the Towers of Hanoi problem.
4.  Set up the recurrence relation for the number of moves in the Towers of Hanoi problem and solve it to determine the algorithm's time efficiency.
5.  Solve the following recurrence relations to determine their order of growth:
    a) T(n) = 2T(n/2) + n, for n > 1, T(1) = 1. (You may assume n is a power of 2).
    b) T(n) = 3T(n-1), for n > 1, T(1) = 4.

6.  Set up and solve the recurrence relation for the time complexity of computing `n!` (factorial) using a recursive algorithm.
7.  State the Master Theorem. Explain its components and when it can be applied to solve recurrence relations.
8.  Use the Master Theorem (if applicable) to find the time complexity for T(n) = 2T(n/2) + n.
9.  Use the Master Theorem (if applicable) to find the time complexity for T(n) = T(n/2) + 1.

### Examples

1.  Design and explain the Sequential Search algorithm. Analyze its time complexity for best-case, worst-case, and average-case scenarios.

2.  Justify the statement: “More than one algorithmic method can be used for solving the same problem.” Do this by:
    a) Describing two distinct algorithms for computing the Greatest Common Divisor (GCD) of two integers (e.g., Euclid's algorithm, prime factorization, or consecutive integer checking).
    b) Analyzing and comparing these two algorithms, discussing their pros, cons, or relative efficiencies.

3.  Illustrate the prime factorization method to find the GCD of two specific numbers, for example, 180 and 30.





## Brute Force

### General Concepts of Brute Force

1.  Define the "Brute Force" approach to problem-solving.
2.  What are the general advantages and limitations of the Brute Force method in algorithm design?
3.  Write two key differences between the Brute Force and Divide-and-Conquer techniques of algorithm design.
4. When might a Brute Force approach be considered a practical or reasonable choice for solving a problem?

### Selection Sort

1.  Describe the Selection Sort algorithm.
2.  Write a clear algorithm or pseudocode for Selection Sort.
3.  Analyze the time complexity of the Selection Sort algorithm.
4.  Trace the execution of the Selection Sort algorithm on the following lists of numbers/characters:
    *   `[81, 43, 66, 87, 21, 34, 15]`
    *   `[89, 45, 68, 90, 29, 34, 17]`
    *   `[234, 155, 409, 119, 789, 721, 345, 678]`
    *   `[S, E, Q, U, E, N, T, I, A, L]` (in alphabetical order)
    *   `[C, O, M, P, U, T, E, R]` (in alphabetical order)
    *   `[45, 90, 20, 100, 75, 30]`
    *   `[S, E, L, E, C, T, I, O, N, S, O, R, T]` (in alphabetical order)
5.  Is Selection Sort a stable sorting algorithm? Explain your answer.

### Brute-Force String Matching

1.  Explain the Brute-Force String Matching algorithm.
2.  Write an algorithm or pseudocode for the Brute-Force String Matching technique.
3.  Analyze the time complexity of the Brute-Force String Matching algorithm.
4.  Trace the Brute-Force String Matching algorithm for the following scenarios:
    *   Pattern: `"COMPUTER"`, Text: `"MASTER OF COMPUTER APPLICATIONS"`
    *   Pattern: `"EE"`, Text: `"ENGINEERING COLLEGE"` (also write the steps)
    *   Pattern: `"NOT"`, Text: `"NOBODY_NOTICED_HIM"` (also determine the number of character comparisons)
    *  Pattern `P`. (e.g., T = `ABABDABACDABABCABAB`, P = `ABABCABAB`)

### Exhaustive Search

1.  Define "Exhaustive Search" as an approach to problem-solving. (How does it relate to Brute force strategy)
2.  Demonstrate the use of Exhaustive Search for the Traveling Salesperson Problem (TSP) with a suitable example.
3.  Solve the following 0/1 Knapsack problem using Exhaustive Search, given a capacity W=10:

| Item | Weight | Value |
|------|--------|-------|
| 1    | 7      | $42   |
| 2    | 3      | $12   |
| 3    | 4      | $40   |
| 4    | 5      | $25   |

4.  Discuss the primary limitations of using Exhaustive Search for solving complex combinatorial problems.

## Divide-and-Conquer

### General Concepts of Divide-and-Conquer
1.  Explain the "Divide-and-Conquer" paradigm in algorithm design. (What are the three fundamental steps involved in this strategy?)
2.  Briefly explain the method for multiplying two large integers based on the Divide-and-Conquer strategy. Analyze its time efficiency using backward substitution (or recurrence relation).
3. What characteristics make a problem well-suited for a Divide-and-Conquer approach?
4. Write down the general form of a recurrence relation that typically describes the time complexity of a Divide-and-Conquer algorithm. How is the Master Theorem often applied in this context?

### Merge Sort
1.  Describe the Merge Sort algorithm, clearly explaining its divide, conquer, and combine steps.
2.  Write an algorithm or pseudocode for Merge Sort.
3.  Analyze the time complexity of Merge Sort.
4.  Is Merge Sort an in-place sorting algorithm? Is it a stable sorting algorithm? Explain.
5.  Trace the Merge Sort algorithm on the following lists of numbers:
    *   `[8, 3, 2, 9, 7, 1, 5, 4]`
    *   `[67, 23, 45, 89, 59, 34, 70, 55]`
    *   `[10, 40, 60, 90, 20, 45]` (show steps in detail and evaluate using a recursive tree)

### Quick Sort
1.  Describe the Quick Sort algorithm, paying special attention to the partitioning step.
2.  Write an algorithm or pseudocode for Quick Sort.
3.  Analyze the time complexity of Quick Sort for its best-case, worst-case, and average-case scenarios (especially when the input is a set of random numbers for the average case).
4.  Trace the Quick Sort algorithm on the following lists of numbers/characters:
    *   `[5, 3, 1, 9, 8, 2, 4, 7]`
    *   `{Q, U, I, C, K, S, O, R, T}`
    *   `[55, 26, 93, 17, 77, 31, 44, 55, 20]`

5.  Explain what conditions lead to the worst-case time complexity in Quick Sort. Discuss common strategies to mitigate this (e.g., randomized pivot selection, median-of-three pivot).
6.  Is Quick Sort an in-place sorting algorithm? Is it a stable sorting algorithm? Explain.

### Binary Search
1.  Explain the recursive Binary Search algorithm.
2.  Illustrate Binary Search with a suitable example.
3.  Write the algorithm for Binary Search.
4.  Prove that the worst-case time complexity of the Binary Search algorithm is O(log₂n) by deriving its recurrence relation.

## Principles of Parallel Algorithm Design

### Preliminaries - Decomposition, Tasks, and Dependency Graphs

1.  Briefly describe the main types of decomposition: task decomposition and data decomposition. What is the primary focus of each?
2.  Explain "data decomposition" in the context of parallel algorithms. What is its use?
3.  Explain partitioning of input data and partitioning of output data as part of data decomposition, using suitable examples.
4.  Explain "Tasks" and "Dependency Graphs" (also known as Task Interaction Graphs) in parallel algorithm design, providing examples.
5.  What is "Critical Path Length" in the context of a task dependency graph?

### Granularity, Concurrency, and Task-Interaction

1.  Define and explain the term "Granularity" in parallel algorithm design.
2.  Define and explain "Degree of Concurrency" in parallel systems.

### Decomposition Techniques

1.  Explain data decomposition techniques in detail with examples.
2.  What is "recursive decomposition"? Present it with an example.
3.  Write short notes on the following decomposition techniques:
    *   Exploratory decomposition
    *   Speculative decomposition



# Decrease and Conquer

- What is meant by the _Decrease and Conquer_ technique? Explain its variations.
    
- Briefly explain the _Decrease and Conquer_ design approach.
    
## Insertion Sort

- Write an algorithm for **Insertion Sort**.
    
- Apply the algorithm to sort the following lists:
    
    1. `189, 145, 168, 190, 129, 134, 117`
        
    2. `89, 45, 68, 90, 29, 32, 17`
        
    3. `89, 26, 47, 12, 54, 32`
        
## Depth-First Search (DFS) and Breadth-First Search (BFS)

- Write **two differences** between DFS and BFS.
    
- Starting at vertex `A`, **traverse the graph** using both BFS and DFS. List the order of visited vertices. _(2023 Sep, Fig 4)_
    
- Starting at vertex `a`, **traverse the graph using DFS** and construct the DFS tree. Indicate the order vertices are reached and become dead ends. _(2020 Sep, Fig 19)_
    
- For the given graph:
    
    - Write the **adjacency matrix** and **adjacency list**.
        
    - Starting at vertex `a` and resolving ties alphabetically, **traverse using DFS**, numbering the order of visits. _(2022 Sep, Fig 8)_
        
- Apply the **DFS-based algorithm** to solve the **Topological Sorting** problem of given graph. _(2021 Oct, 2021 Sep, Fig 12 & Fig 14)_
    
- Give the **pseudocode** for DFS. Apply it to the given graph starting at vertex `a`, and construct the DFS tree. Give the order in which the vertices are reached and became dead ends. _(2021 Feb, Fig 19)_
    
- For the directed graph with edge set `{(a,b), (b,c), (a,c), (c,d), (c,e), (e,f), (f,a), (f,g), (h,k), (k,l)}`: has to be traversed using DFS. Draw the graph. Show the stack and DFS tree. list the properties of this graph, revealed after the traversal. 
	
- Identify the **suitable traversal technique** when data needs to be accessed from one node to all others. Justify your answer.
    
- Write the algorithm which uses **stack** as data structure and apply it to the given network. _(2020 Jan, Fig 12)_
    
## Topological Sorting

- A student can study design and analysis of algorithms(DAA) with the pre knowledge of data structures (DS) and discrete mathematics (DM). Data base management system(DBMS) and DAA further helps the student to learn Data Analytics(DA).
- A student needs DS and DM to study DAA. DAA and DBMS help in studying DA.
    - Construct a graph and **find the topological order**.
    - State the **minimum condition** for a valid topological sort.
	
- Define **Topological Order**.
    - As a student of the course studying design and analyze all the subjects pre knowledge requirement to study the Computer Networking and Design and Analysis of Algorithm..
    - Construct the graph and determine the topological order for the scenario.
        
- Define **Topological Sorting**.
    
    - Apply the **Source Removal algorithm** to solve the topological sorting problem. _(2023 Sep, Fig 5)_
        
    - Apply the same algorithm to another graph. _(2022 Sep, Fig 9)_
        
    - Topological sorting. _(2020 Sep, Fig 20)_
        
## Generating Combinatorial Objects

### Generating Permutations & Subsets

- Explain **any two methods** for generating permutations with an example.
    
- Discuss the **Minimal Change Method** and **Johnson-Trotter Algorithm** for generating permutaions with examples.
    
- Write the **Johnson-Trotter Algorithm** to generate permutations and solve for `{1, 2, 3}`.
    
---

# Transform and Conquer

## Presorting

- What is **Presorting**?
    
- How can presorting help solve the **Element Uniqueness Problem**? Write an algorithm and analyze its time efficiency.
    
- Write an algorithm to check **element uniqueness in an array** using presorting.
    
- Write an algorithm to find the **mode** of a dataset using presorting and discuss time complexity.
    
- Write algorithms for **mode calculation**:
    
    - (i) When the list is not sorted
        
    - (ii) When the list is pre-sorted  
        Compare the time efficiency of both approaches.
        
---

## Heaps: Notion of Heap and Heapsort

- Define a **Heap** and its types.
    
- Write the **Bottom-Up algorithm** to construct a heap.
    
- Apply the Bottom-Up algorithm to the following lists:
    
    1. `4, 12, 9, 8, 7, 10` (include pictorial representation)
        
    2. `1, 8, 6, 5, 3, 7, 4` (pictorial representation at each step)
        
    3. `14, 22, 19, 18, 17, 10` (pictorial representation at each step)
        
- Design an algorithm for **Heap Sort** and solve using the list: `1, 8, 6, 5, 3, 7, 4, 9`.
    
- Sort the list `3, 2, 4, 1, 6, 5` in ascending order using **Heap Sort with array representation**. Provide pictorial steps.
    
- Apply **Heap Sort** to sort the list: `23, 34, 12, 10, 5, 18, 20, 25`.
    





# Space and Time Tradeoffs

## Sorting by Counting

1. Design an algorithm for **Sorting by Counting**. Trace the algorithm with an example.
    
2. Explain the algorithm for **Sorting by Distribution Counting**.
    
3. Assuming the set of possible values is `{a, b, c, d}`, sort the list `b, c, d, c, b, a, a, b` alphabetically using Distribution Counting algorithm.
    
4. Given the set `{62, 31, 84, 96, 19, 47}`, sort the list using the **Counting Sort** algorithm.
    
5. Develop the algorithm for sorting using **Distribution Counting** and sort the list `13, 11, 12, 13, 12, 12`.
    
6. Write an algorithm for **Distribution Counting** and apply it to sort the list `7, 6, 7, 8, 8, 7`. Also, find the time complexity.
    
## Hashing – Open Hashing, Closed Hashing

1. Define **Hashing**. Explain the two mechanisms to resolve collisions in **Closed Hashing**.
    
2. What is hashing? Explain **two collision resolution techniques** with examples and give their mathematical analysis.
    
3. For the input `{30, 20, 56, 75, 31, 19}`, construct the **Open Hash Table** using the hash function `h(k) = k mod 11`. Find the largest number of key comparisons in a **successful search**.
    
4. For the inputs `{apple, lemon, and, kiwi, are, grapes}` and the hash function `h(k) = k mod 13`, construct: Open Hash Table and Closed Hash Table.

# Dynamic Programming

1. Develop **Warshall’s Algorithm** to find the transitive closure of a matrix. Apply it to a given directed graph. _(2024 Sep, Fig 2)_
    
2. Explain **Warshall’s Algorithm**. Apply it to compute the transitive closure of the following directed graph. _(2023 Sep, Fig 6)_
    
3. Write **Floyd’s Algorithm**. Apply it to find the **distance matrix** of the given graph. _(2021 Feb, Fig 18)_
    
4. In a **star topology** with 5 nodes, packets must be transmitted between all pairs. Using a given graph, find the shortest routes using **Floyd’s Algorithm**. _(2020 Sep, Fig 21)_
    
# Greedy Technique

## Kruskal’s Algorithm

1. Define a **Spanning Tree**.
    
2. Write **Kruskal’s Algorithm** for constructing a **Minimum Spanning Tree (MST)**.
    
3. Trace Kruskal’s Algorithm for the given graph and construct the MST. _(2022 Sep, Fig 11)_
    
4. Apply **Kruskal’s Algorithm** to a graph and find the MST. _(2021 Feb, Fig 17)_
    
5. Apply Kruskal’s Algorithm to a given graph and state its **time complexity**. _(2020 Sep, Fig 22)_
    
## Dijkstra’s Algorithm

1. Apply **Dijkstra’s Algorithm** to find the **shortest path** from vertex `B` to all other vertices in the graph. List all shortest paths. _(2024 Sep, Fig 1)_
    
2. Write Dijkstra’s Algorithm and apply it to find the shortest paths from node `A` to all other nodes. _(2022 Sep, Fig 10)_
    
3. Apply Dijkstra’s Algorithm from vertex `B` to all other vertices and list all shortest paths. _(2021 Sep, Fig 15)_
    
## Huffman Trees

1. Describe **Huffman’s Algorithm**. Construct a Huffman Tree and obtain the Huffman codes for the following data:
    
|Character|A|B|C|D|E|
|---|---|---|---|---|---|
|Probability|0.25|0.15|0.20|0.10|0.30|

2. Construct a Huffman Tree for the following data and encode the text **DAB-AC**:
    
|Character|A|B|C|D|`-`|
|---|---|---|---|---|---|
|Probability|0.4|0.1|0.2|0.15|0.15|


# Backtracking

## N-Queens Problem

1. Compare **Backtracking** and **Branch-and-Bound** programming techniques.
    
2. What is **backtracking**? Explain how it can be used to solve the **n-Queens problem**, and obtain **one solution** for the **4-Queens** problem using a **state space tree**.
    
3. Explain the **Backtracking algorithm** and apply it to solve the **4-Queens problem**.
    
4. Apply Backtracking to find **all possible solutions** to the **4-Queens problem**.  

## Hamiltonian Circuit Problem

1. Define a **Hamiltonian Circuit**.
	
2. Compare **Brute Force** and **Backtracking** methods for finding **Hamiltonian circuits** in a graph.   
	
3. Apply **Backtracking** to find all possible solutions to the **Hamiltonian circuit problem**. _(2023 Sep, Fig 7)_
    
4. Apply **Backtracking** to the problem of finding a **Hamiltonian circuit** in the given graph. _(2021 Sep, Fig 13)_
	
5. Illustrate how **Backtracking** can be applied to a given graph to find a Hamiltonian Circuit. _(2021 Sep, Fig 16)_
 
## Subset-Sum Problem

1. Solve the **Subset-Sum problem** using **Backtracking**. Draw the **state-space tree** for the instance: S={3,5,6,7}, d=15
      
2. Solve the Subset Sum problem using Backtracking for the instance: S={1,2,5,6,8}, d=9
        
3. Apply **Backtracking** to solve the following instance and construct the **state-space tree**: S={1,3,4,5}, d=11

# Branch-and-Bound

## Knapsack Problem

1. Find the **maximum profit** using **Branch and Bound** for the following instance of knapsack problem: W=16

|Item|Weight|Value|
|---|---|---|
|1|10|$100|
|2|7|$63|
|3|8|$56|
|4|4|$12|

2. Solve using Branch-and-Bound for the following instance: W=15

|Item|Weight|Value|
|---|---|---|
|1|5|$40|
|2|7|$35|
|3|2|$18|
|4|4|$4|
|5|5|$10|
|6|1|$2|

3. Apply Branch and Bound technique to the following instance: W = 15

| Item | Weight | Value |
| ---- | ------ | ----- |
| 1    | 2      | $18   |
| 2    | 5      | $40   |
| 3    | 7      | $35   |
| 4    | 4      | $12   |
| 5    | 1      | $2    |
| 6    | 4      | $4    |

4. Solve the following **Knapsack instance** using **Branch and Bound**. W = 16

| Person | Job1 | Job2 | Job3 | Job4 |
| ------ | ---- | ---- | ---- | ---- |
| A      | 9    | 2    | 7    | 8    |
| B      | 6    | 4    | 3    | 7    |
| C      | 5    | 8    | 1    | 8    |
| D      | 7    | 6    | 9    | 4    |

| Person | Item | Weight | Value |
| ------ | ---- | ------ | ----- |
| A      | 1    | 10     | $100  |
| B      | 2    | 7      | $63   |
| C      | 3    | 8      | $56   |
| D      | 4    | 4      | $12   |

## Traveling Salesman Problem

1. Solve the **Traveling Salesman Problem** using **Branch and Bound**. _(2024 Sep, Fig 3)_
    
2. Find the **optimal route** using Branch and Bound for the cost matrix:

|     | A   | B   | C   | D   |
| --- | --- | --- | --- | --- |
| A   | 0   | 2   | 5   | 7   |
| B   | 2   | 0   | 8   | 3   |
| C   | 5   | 8   | 0   | 1   |
| D   | 7   | 3   | 1   | 0   |

# P, NP-Completeness, and Approximation Algorithms

## P and NP Problems, NP-complete Problems

1. Write a short note on **P**, **NP**, **NP-complete**, and **NP-hard** problems.
    
2. Define the following:
    
    - i) **Tractable Problem**
        
    - ii) **NP-complete Problems**
        
    - iii) **Feasible Solution**
        
## Approximation Algorithms

1. Discuss two approximation algorithms used to solve the Traveling Salesman Problem.

2. Discuss approximation algorithms used for solving the Knapsack Problem.
    
