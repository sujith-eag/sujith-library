# Part 2: Procurement, Development, and Operation

## System Procurement

### I. Key Definition and Drivers

System procurement (or system acquisition) is the process of deciding **what system to buy and who should supply that system**.

- **Key Decisions:** At this stage, decisions are made on the system scope, budgets, timescales, and high-level requirements.
    

#### Drivers for Procurement Decisions

The decision drivers for procurement are:

1. Organizational needs (including strategic objectives).
    
2. Budget and schedule constraints.
    
3. High-level system requirements.
    

### II. Types of Systems Procured

The procurement approach depends on the type of system or component needed:

1. **Off-the-shelf Applications:** Systems that can be used without changes and require minimal configuration.
    
2. **Configurable Application or ERP Systems (COTS):** Generic, large-scale systems (like SAP or Oracle) that must be adapted through configuration features or code modification.
    
3. **Custom Systems:** Systems that must be specially designed and implemented.
    

### III. Procurement Processes (By System Type)

The procurement process varies depending on the system type:

|**System Type**|**Core Activities**|**Requirements Status**|
|---|---|---|
|**Off-the-shelf Systems**|Conceptual design, assessing approved applications, and placing the order.|Requirements usually match or are adapted post-selection.|
|**Configurable Systems**|Market survey, choosing a shortlist, **refining requirements** to match candidate systems, choosing a supplier, and contract negotiation.|Requirements must often be modified or adapted to fit the system's assumptions.|
|**Custom Systems**|**Defining detailed requirements** (which form the legal contract), issuing a request for tender, choosing a supplier, and contract negotiation.|Requirements document is **critical** and part of the contract.|

#### A. Core Concepts on Requirements and Contracts

- **Legal Documents:** For custom systems, the requirements document becomes a **legal document** and the basis for the contract.
    
- **Public Sector Constraints:** For public sector systems, detailed rules require all systems above a certain price to be open to tender, which forces system buyers to develop **complete requirements upfront** so all companies can bid. This constraint slows down the process and inhibits agile development.
    
- **Negotiation:** Contract negotiations for custom systems cover payment schedules, reporting, acceptance criteria, and costs of change requests.
    

### IV. Challenges and Consequences

#### A. The Criticality of Procurement Decisions

- Decisions made at the procurement stage are **critical for later stages**; poor choices lead to late delivery and systems unsuited to their operational environment.
    
- If the wrong system is chosen (e.g., an ERP system that cannot handle organizational diversity), the system may be **abandoned** after major costs are incurred.
    
- Choosing to procure a custom system requires significant effort in defining complex requirements (e.g., dependability), which can substantially extend time and budget.
    

#### B. Non-Technical Influences

- **Political Motivation:** Many bad procurement decisions stem from political rather than technical causes.
    
- **Examples of Political Drivers:** Senior management demanding a single system across the organization; suppliers chosen based on long-standing relationships; or managers preferring compatibility with existing systems rather than new, superior technology.
    

---

**Analogy for System Engineering vs. System Procurement:**

If **Systems Engineering** is the master plan for building a new national railway network (defining the tracks, the trains, the scheduling rules, and the staff training), then **System Procurement** is the specific stage where the government chooses _which_ companies will supply the specialized steel for the tracks, _which_ manufacturer will build the locomotives, and _which_ contractor will implement the ticketing software, all based on predefined requirements and legal contracts. Procurement formalizes the financial and contractual aspects of the high-level engineering plan.


## System Development

### I. Definition and Core Concepts

- **Definition:** System development is the complex process in which system elements (developed or purchased) are **integrated to create the final system**.
    
- **Process Model:** Higher-level systems engineering processes are typically **plan-driven processes** (often following a waterfall model) rather than incremental models.
    
- **Rationale for Plan-Driven Approach:** This approach is necessary because different elements (hardware, software, buildings) are developed **independently and concurrently** by different contractors. Therefore, all interfaces must be fully defined before development begins, as changes (especially to hardware) are often expensive or impossible later on.
    
- **Relationship with Requirements/Design:** System development is inextricably linked with requirements development and high-level design; these processes are often concurrent, following a **spiral model** where requirements and architectural design are developed and refined together.
    
- **Goal:** The process culminates in a "go live," after which users begin to use the system to support their work.
    

### II. Key Development Activities (Process Steps)

The systems development stage includes seven fundamental activities after the initial conceptual design:

1. **Requirements Engineering:** The process of refining, analyzing, and documenting the high-level and business requirements identified earlier in the conceptual design.
    
2. **Architectural Design:** Identifying the overall structure of the system, the principal components (subsystems or modules), their relationships, and how they are distributed.
    
3. **Requirements Partitioning:** Deciding which components (hardware, software, or operational processes) are responsible for implementing the requirements.
    
4. **Subsystem Engineering:**
    
    - Developing the software components of the system.
        
    - Configuring off-the-shelf hardware and software components.
        
    - Designing special-purpose hardware, if necessary.
        
    - Defining the operational processes and redesigning essential business processes.
        
5. **System Integration:** The critical process of **putting together system elements** to create the new system. This is the stage where **emergent system properties** (like performance and security) first become apparent.
    
6. **System Testing:** An extended activity where the whole system is tested and problems are exposed. This includes acceptance/user testing by the procuring organization.
    
7. **System Deployment:** Making the system available to its users, including transferring data from existing systems and establishing communications with other systems in the environment.
    

### III. Implementation and Quality Practices in Development

- **Design and Implementation:** These activities are invariably interleaved. In an agile approach, formal design documents may be minimized or recorded informally on whiteboards, with design decisions left to the programmers.
    
- **Configuration Management (CM):** CM is essential during development because components are changed several times a day.
    
    - The **development phase** focuses on adding new functionality.
        
    - The **system testing phase** focuses on bug fixes, performance improvements, and security repairs; no new functionality is added.
        
    - Tools (like Git or Subversion) are required to maintain a shared project repository and manage versions to prevent developers from overwriting each other’s work.
        
- **System Building (Integration):** System building is the process of creating a complete executable system by compiling and linking components, external libraries, and configuration files.
    
    - **Continuous Integration (CI):** Software should be **frequently rebuilt and tested immediately** after a new version is created (often daily or more often).
        
    - **Benefits of CI:** CI increases the chances of finding problems stemming from component interactions early on, encourages thorough unit testing, and puts psychological pressure on developers not to "break the build".
        
- **Testing:** Development testing is performed to discover bugs and defects. It should be an incremental activity, starting as soon as code is written.
    
    - Development testing includes **Unit testing** (individual program units/classes), **Component testing**, and **System testing** (checking component compatibility and interfaces).
        
    - **Test-Driven Development (TDD):** A methodology pioneered in agile methods where tests are written _before_ the code to be tested.
        

## System Operation and Evolution

### I. System Operation and Deployment

- **Operation Stage:** This stage occurs after the system is deployed and users are trained. The system is put into practical use.
    
- **Operational Processes:** These are the processes involved in using the system as intended by its designers. These processes are defined during the system development process.
    
- **Post-Deployment Change:** The planned operational processes **usually have to change** to reflect the real working environment. Undetected problems may arise because the initial system specification contained errors or omissions, leading to operators using the system in ways not intended by the designers.
    
- **Deployment Challenges:** Deployment is often more difficult and costly than anticipated because the user environment may differ from what was expected, existing system data may need extensive clean-up, and user training may be inadequate.
    

### II. Software Evolution and Maintenance

#### A. Core Concepts and Definitions

|**Term**|**Key Definition**|
|---|---|
|**Software Evolution**|The process where software is **continually changed** over its lifetime in response to changing requirements and customer needs. It is seen as a continuum rather than a separate process from development.|
|**Software Maintenance**|The general process of **changing a system after it has been delivered**. This term is usually applied to **custom software** where separate development groups are involved before and after delivery.|
|**Legacy System**|A sociotechnical system that is **useful or essential** to an organization but has been developed using **obsolete technology or methods**. They often perform critical business functions.|

#### B. The Evolution Process (The Longest Phase)

- **Duration:** Operation and maintenance is normally the **longest life-cycle phase**. Large complex systems typically have a long lifetime (20+ years) due to high investment, business dependence, and system dependencies.
    
- **Process Drivers:** Evolution is driven by formal or informal **system change proposals** (requests for new requirements, bug reports, or platform adaptation).
    
- **Evolution Process Steps:** The process is cyclical and includes:
    
    1. **Change Identification Process:** Identifying changes based on user feedback or new requirements.
        
    2. **Software Evolution Process (Implementation):** Revisions are designed, implemented, and tested (reentering the development process).
        
    3. **System Release:** Delivering the updated version.
        

#### C. Challenges and Costs of Evolution

- **High Cost:** The cost of **software maintenance usually exceeds the initial software development costs** for custom systems.
    
- **Reasons for High Cost:**
    
    1. **System Complexity and Degradation:** As systems age, their structure becomes corrupted by continuous change, making subsequent changes more difficult and costly.
        
    2. **Side-Effects:** Changes to one subsystem often have **side-effects** that adversely affect others, necessitating cascading changes.
        
    3. **Obsolete Technology:** Systems may be implemented using **obsolete programming languages**, making it difficult to find knowledgeable staff for maintenance.
        
    4. **Lack of Program Understanding:** Where development and maintenance teams are separate, the new team must perform **program understanding** (reverse-engineering the structure and function of the code) before making changes, often due to inadequate or out-of-date documentation.
        
- **Agile vs. Plan-Based Maintenance:**
    
    - Agile enthusiasts argue that high-quality, readable code is sufficient, and formal documentation is often outdated.
        
    - Conversely, detailed documentation, especially the **system requirements document**, is critical for maintenance engineers to assess the impact of proposed changes; the lack of a coherent requirements document in agile-developed systems can make maintenance more difficult and expensive.
        

#### D. Legacy Systems

- **Legacy Components:** Legacy systems consist of hardware, obsolete support software (compilers, debuggers), and application software (programs developed at different times).
    
- **Legacy Data:** They often hold an **immense volume of data** accumulated over the system’s lifetime, which may be inconsistent or duplicated across files.
    
- **Reengineering:** When a legacy system is modified to make it easier to understand and change, this is called **reengineering**. This may involve software and data restructuring, or **wrapping** the legacy system with adaptor services that hide its original interfaces and present new, better-structured interfaces for use by other components.
