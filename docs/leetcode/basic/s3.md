## Increasing Triplet Subsequence (LeetCode 334)

Given an integer array `nums`, return `true` if there exists a triple of indices `(i, j, k)` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. Otherwise return `false`.

|Input|Output|Explanation|
|---|---|---|
|`[1,2,3,4,5]`|`true`|Any ascending triplet works.|
|`[5,4,3,2,1]`|`false`|No ascending triplet exists.|
|`[2,1,5,0,4,6]`|`true`|Triplet (0,4,6) found.|
|`[20,100,10,12,5,13]`|`true`|Triplet (10,12,13) found.|
|`[6,7,1,2]`|`false`|Only descending pairs.|
|`[5,1,6]`|`false`|Not enough ascending elements.|

- **It’s not about consecutive numbers** — indices can be far apart.
    
- We cannot just count or reset counters.
    
- We need to **track two smallest numbers** as we scan the array.
    
- If we ever find a number greater than both tracked numbers → **triplet exists**.
    
---

### Initialization Tricks

- `float('inf')` → positive infinity (initializing **minimums**).
    
- `float('-inf')` → negative infinity (initializing **maximums**).
    
- In Java → use `Integer.MAX_VALUE` and `Integer.MIN_VALUE`.
    

---

### Algorithm (Greedy)

We maintain two variables:

- `first` = smallest number seen so far.
    
- `second` = smallest number greater than `first`.
    

For each `num`:

1. If `num <= first` → update `first`.
    
2. Else if `num <= second` → update `second`.
    
3. Else → found `num > second > first` → return `true`.
    

If the loop ends without finding such `num`, return `false`.

**O(n)** time and **O(1)** extra space.

---

### Python Implementation (Optimal)

```python
def increasingTriplet(nums):
    if len(nums) < 3:
        return False

    first = float('inf')
    second = float('inf')

    for num in nums:
        if num <= first:         # smallest so far
            first = num
        elif num <= second:      # second smallest
            second = num
        else:                    # num > second > first
            return True

    return False
```

---

### Java Implementation (Optimal)

```java
class Solution {
    public boolean increasingTriplet(int[] nums) {
        if (nums.length < 3) return false;

        int first = Integer.MAX_VALUE;
        int second = Integer.MAX_VALUE;

        for (int num : nums) {
            if (num <= first) {
                first = num; // smallest so far
            } else if (num <= second) {
                second = num; // second smallest
            } else {
                // Found num > second > first
                return true;
            }
        }

        return false;
    }
}
```

---

### Why This Works

Example `nums = [2,1,5,0,4,6]`:

- Start: first = inf, second = inf.
    
- num=2 → first=2.
    
- num=1 → first=1.
    
- num=5 → second=5.
    
- num=0 → first=0.
    
- num=4 → second=4.
    
- num=6 → 6>4>0 → return True.
    
Triplet found.

---

### Common Mistakes

- Using only a counter of increasing elements (fails for non-consecutive indices).
    
- Resetting `min` incorrectly (loses track of earlier small numbers).
    
- Not handling equal numbers properly (use `<=` not `<`).
    

---

- **Time Complexity:** O(n)
    
- **Space Complexity:** O(1)
    

---

### Key Takeaways

- Always track **two thresholds** (first and second).
    
- The moment you find a number larger than both, the answer is `true`.
    
- This is a classic example of a **greedy linear scan**.
    
