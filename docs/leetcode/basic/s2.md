## Product of Array Except Self (LeetCode 238)

Given an integer array `nums`, return an array `answer` such that `answer[i]` is the product of all elements of `nums` except `nums[i]`.
- The product of any prefix or suffix fits in a 32-bit integer.
- No division allowed    
- should run in **O(n) time**

| Input           | Output        |
| --------------- | ------------- |
| `[1,2,3,4]`     | `[24,12,8,6]` |
| `[-1,1,0,-3,3]` | `[0,0,9,0,0]` |

---

- **Prefix products:** product of all elements to the left of index `i`.
- **Suffix products:** product of all elements to the right of index `i`.    
- **Multiplying prefix and suffix** at each index gives product except self.
    
```
[1,   2,   3,  4,  5,  6]    Int list
[-,   1,   2,  6,  24, 120]   Prefixes
[720,360, 120, 30,  6,  -]    Sufixes
[720,360, 240, 180, 144, 120]  Result
```

---

### Approach 1: With Division (Easy but Not Allowed)

1. Compute total product of array.
    
2. If no zeros: `answer[i] = total_product / nums[i]`.
    
3. If one zero: only that index gets the product of all non-zero numbers.
    
4. If more than one zero: all zeros in result.
    
(Works but violates problem’s “no division” constraint.)

---

### Approach 2: Prefix and Suffix Products (Optimal)

- For each index `i`:
    
    - `prefix[i]` = product of elements before `i`.
        
    - `suffix[i]` = product of elements after `i`.
        
    - `result[i] = prefix[i] * suffix[i]`.
        
We do this in **two passes** without extra prefix/suffix arrays if we’re clever.

---

### Step-by-Step (with arrays)

1. Create `prefix` array of size `n` initialized to 1.
    
2. Create `suffix` array of size `n` initialized to 1.
    
3. Fill `prefix`:
    
    - `prefix[0] = 1`
        
    - `prefix[i] = prefix[i-1] * nums[i-1]` for `i > 0`.
        
4. Fill `suffix`:
    
    - `suffix[n-1] = 1`
        
    - `suffix[i] = suffix[i+1] * nums[i+1]` for `i < n-1`.
        
5. Compute `result[i] = prefix[i] * suffix[i]`.
    
---

### Optimized Approach (No Extra Suffix Array)

We can do it in two passes with only the result array:

- **Pass 1 (Left Products):** store prefix products directly in `result[i]`.
    
- **Pass 2 (Right Products):** maintain a running `right` product and multiply into `result[i]`.
    
---

### Python (Prefix & Suffix Arrays)

```python
def productExceptSelf(nums):
    n = len(nums)
    prefix = [1] * n
    suffix = [1] * n
    result = [1] * n

    pre = 1
    for i in range(n):
        prefix[i] = pre
        pre *= nums[i]

    suf = 1
    for i in range(n-1, -1, -1):
        suffix[i] = suf
        suf *= nums[i]

    for i in range(n):
        result[i] = prefix[i] * suffix[i]

    return result
```

---

### Python (Most Optimized – Single Result Array)

```python
def productExceptSelf(nums):
    n = len(nums)
    result = [1] * n

    # Left products
    left = 1
    for i in range(n):
        result[i] = left
        left *= nums[i]

    # Multiply by right products
    right = 1
    for i in range(n-1, -1, -1):
        result[i] *= right
        right *= nums[i]

    return result
```

**O(n)** time, **O(1)** extra space (excluding output array).

---

### Java Version – Most Optimized

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];

        // Pass 1: store prefix products
        int left = 1;
        for (int i = 0; i < n; i++) {
            result[i] = left;
            left *= nums[i];
        }

        // Pass 2: multiply by suffix products
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] *= right;
            right *= nums[i];
        }

        return result;
    }
}
```

---

### **How It Works (Example)**

`nums = [1, 2, 3, 4]`

- **Left pass (prefix):** `[1, 1, 2, 6]`
    
- **Right pass (suffix):** multiply `[6*24, 2*12, 1*4 …]` → `[24,12,8,6]`
    
Done in **two passes** with constant space.

---

- **Time Complexity:** O(n)
    
- **Space Complexity:** O(1) extra (result array not counted).
    

---

### Key Takeaways

- Prefix × Suffix = Product Except Self.
    
- Two passes (left then right) achieve O(n) with no division.
    
- Always handle zeros naturally; prefix/suffix method works even with zeros.
    
